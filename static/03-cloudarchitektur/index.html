<!DOCTYPE html>
<html lang="de">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <title>Cloud-Architekturmuster | Verteilte Systeme</title>

        <script src="../_bundle.js"></script>
        <link rel="stylesheet" href="../_bundle.css" />
        <link rel="shortcut icon" href="../favicon.png" />

        <script>
            function change_example(event) {
                let label             = event.target.textContent       || "";
                let dropdownSelector  = event.target.dataset.dropdown  || "";
                let containerSelector = event.target.dataset.container || "";
                let showSelector      = event.target.dataset.show      || "";

                if (dropdownSelector) {
                    document.querySelectorAll(dropdownSelector).forEach(element => element.textContent = label);
                }
                if (containerSelector) {
                    document.querySelectorAll(`${containerSelector} > *`).forEach(element => element.classList.add("hidden"));
                }

                if (showSelector) {
                    document.querySelectorAll(showSelector).forEach(element => element.classList.remove("hidden"));
                }
            }
        </script>
    </head>

    <body class="hidden">
        <!-- Seitenkopf und Inhaltsverzeichnis -->
        <header>
            <div id="title">
                <h1>Cloud-Architekturmuster</h1>
                <h2 id="page-title"></h2>
            </div>

            <section id="toc" data-title="Inhaltsverzeichnis"></section>
        </header>

        <!-- Folien -->
        <main>
            <!-- ========== -->
            <!-- Einleitung -->
            <!-- ========== -->
            <section data-title="Einleitung" data-chapter></section>
            
            <section data-title="Lernziele" data-background-image="../trennfolie.jpg">
                <div class="card flex-fill mb-3">
                    <div class="card-header fw-bold dhbw-lightblue">
                        Skalierung in der Cloud
                    </div>
                    <div class="card-body p-3 markdown">
                        * Das Cloud-Betriebsmodell von klassischem Hosting unterscheiden können
                        * Verschiedene Arten von **As-a-Service**-Angeboten einordnen können
                        * Die Vor- und Nachteile einer **Microservice-Architektur** erklären können
                        * Die typischen Probleme monolithischer Anwendungen einordnen können
                        * **Elastizität und Skalierung** in der Cloud beschreiben können
                        * Die Begriffe **12-Faktor-App** und **Cloud Native App** erklären können
                        * Typische Architekturmuster wie **API-Gateway** <!-- oder **Cloud Messaging** --> kennen
                    </div>
                </div>
                <!--
                <div class="card flex-fill mb-3">
                    <div class="card-header fw-bold dhbw-lightblue">
                        Umgang mit Fehlersituationen
                    </div>
                    <div class="card-body p-3 markdown">
                        * Die Wichtigkeit von **Observability** für verteilte Anwendungen verstehen
                        * Nutzen und Zusammenspiel von **Logs, Traces und Metriken** beschreiben können
                        * **Technische Strategien zur Fehlerbehandlung** wie das Circuit Breaker Pattern kennen
                        * **Fachliche Strategien zur Fehlerbehandlung** wie Compensating Action kennen
                        * Die Vor- und Nachteile dezentral implementierter Geschäftslogik kennen
                    </div>
                </div>
                <div class="card flex-fill">
                    <div class="card-header fw-bold dhbw-lightblue">
                        Cloud-Anwendungen absichern
                    </div>
                    <div class="card-body p-3 markdown">
                        * Die Begriffe **Data at Rest** und **Data in Transit** kennen
                        * Die Begriffe **Authentizität**, **Vertraulichkeit** und **Integrität** abgrenzen können
                        * Sicherungsmaßnahmen auf Netzwerkebene wie SSL oder **Network Level Isolation** verstehen
                        * Anwendungsfälle und die grundsätzliche Implementierung von **OAuth** kennen
                    </div>
                </div>
                -->
            </section>

            <!-- ============================= -->
            <!-- Definition des Cloud-Begriffs -->
            <!-- ============================= -->
            <section data-title="Definition des Cloud-Begriffs" data-chapter></section>
            <section data-title="Definition des Cloud-Begriffs" data-background-image="../trennfolie.jpg"></section>

            <section data-title="Grundlagen der Cloud-Architektur" class="limited-width">
                <lsx-youtube video="_epyprLse_4" aspect-ratio="16x9" style="width: 50em; max-width: 100%;"></lsx-youtube>
                <a href="https://youtu.be/_epyprLse_4" target="_blank">Link zum Video</a>

                <lsx-info-box type="warning" class="mt-3">
                    Das Video bezieht sich an manchen Stellen noch auf die Entwicklung mit Java und
                    dem Spring-Framework. Auch wenn wir inzwischen Node.js/JavaScript in der Vorlesung
                    verwenden, sind die Grundprinzipien jedoch dieselben.
                </lsx-info-box>
            </section>

            <section data-title="Die Cloud aus Konsumentensicht" class="dhbw-limited-width2">
                <img src="cloud-storage.png" class="d-block w-100 mb-5">

                <div class="d-flex flex-column flex-md-row gap-2">
                    <img src="cat1.jpg" class="d-block w-100 img-thumbnail">
                    <img src="cat2.jpg" class="d-block w-100 img-thumbnail">
                    <img src="cat3.jpg" class="d-block w-100 img-thumbnail">
                    <img src="cat4.jpg" class="d-block w-100 img-thumbnail">
                </div>

                <small>
                    <small>
                        Zitat gefunden auf:
                        <a href="https://docs.kraudcloud.com/technology/storage/" target="_blank">kraudcloud.com</a>, <br>
                        
                        Bildnachweise:
                        <a href="https://pixabay.com/photos/cat-pet-licking-animal-tabby-cat-323262/" target="_blank">Pixabay: TeamK</a>,
                        <a href="https://pixabay.com/photos/cat-kitten-pets-animals-housecat-2934720/" target="_blank">Pixabay: Kirgiz03</a>,
                        <a href="https://pixabay.com/photos/cat-siamese-cat-fur-kitten-2068462/" target="_blank">Pixabay: webandi</a>,
                        <a href="https://pixabay.com/photos/cat-tired-yawn-stretch-814952/" target="_blank">Pixabay: jonathansautter</a>
                    </small>
                </small>
            </section>

            <section data-title="Abgrenzung von typischen Onlinediensten" class="dhbw-limited-width2">
                <div class="markdown mt-3 mb-3">
                    Anwendungen zum Synchronisieren von Dateien wie Dropbox, OneDrive oder Owncloud
                    werden umgangssprachlich oft als Cloud bezeichnet. Man sagt, dass die Dateien
                    _mit der Cloud synchronisiert_ werden. Dies ist jedoch problematisch, da „Cloud”
                    hier lediglich sinnbildlich für einen irgendwie gearteten Onlinedienst steht.
                    Hinzu kommt, dass zumindest Owncloud gar keine Cloud-Anwendung ist, sondern eine
                    in PHP implementierte, traditionelle Webanwendung. Nach dieser Definition müsste
                    demnach jede Webanwendung auch eine Cloud-Anwendung sein.
                </div>

                <lsx-grid-fluid class="p-0">
                    <lsx-row>
                        <lsx-col size="md">
                            <img src="dropbox-screenshot.png" class="d-block img-thumbnail" style="height: 100%;"/>
                        </lsx-col>
                        <lsx-col size="md">
                            <img src="owncloud-screenshot.png" class="d-block img-thumbnail" style="height: 100%;"/>
                        </lsx-col>
                    </lsx-row><lsx-row>
                        <lsx-col size="md">
                            <img src="owncloud-quellcode.png" class="d-block img-thumbnail" style="height: 100%;"/>
                        </lsx-col>
                        <lsx-col size="md">
                            <img src="owncloud-installation.png" class="d-block img-thumbnail" style="height: 100%;"/>
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </section>

            <section data-title="Abgrenzung von klassischem Hosting" class="dhbw-limited-width2">
                <div class="markdown mt-3 mb-3">
                    Schon früher war es insbesondere für kleinere Unternehmen üblich, die Hardware zur
                    Bereitstellung eines Onlinedienstes nicht selbst zu betreiben. Dieses Modell wird
                    Hosting genannt, da der Anbieter zwar die Hardwareplattform (den Host) zur Verfügung
                    stellt, Installation und Betrieb der Anwendung aber immer noch selbst vorgenommen
                    werden müssen.
                </div>

                <div class="d-flex gap-3 flex-column flex-md-row">
                    <div class="card flex-grow-1 w-100">
                        <img src="hosting-dedicated.jpg" class="card-img-top">
                        <div class="card-header border-top fw-bold">
                            Dedicated Root Server                        
                        </div>
                        <div class="card-body markdown small">
                            Hier vermietet der Anbieter einen dedizierten Computer an den Kunden.
                            Installation und Einrichtung müssen, sofern es kein „managed” Angebot
                            mit zusätzlicher Dienstleistung ist, aus der Ferne selbst erledigt werden.
                            Im Gegenzug können jedes beliebige Betriebsystem und jede Software
                            aufgespielt werden.
                        </div>
                    </div>

                    <div class="card flex-grow-1 w-100">
                        <img src="hosting-vserver.png" class="card-img-top">
                        <div class="card-header border-top fw-bold">
                            Virtual Private Server
                        </div>
                        <div class="card-body markdown small">
                            Hier steht eine virtuelle Maschine zur Verfügung, die sich weitgehend wie
                            dedizierte Hardware nutzen lässt. Die Ressourcen können jedoch geringer
                            ausfallen, da die Hardware von vielen Kunden geteilt wird. Die Installation
                            eines eigenen Betriebssystems kann ebenfalls mit Einschränkungen verbunden sein.
                        </div>
                    </div>

                    <div class="card flex-grow-1 w-100">
                        <img src="hosting-web.png" class="card-img-top">
                        <div class="card-header border-top fw-bold">
                            Web Hosting
                        </div>
                        <div class="card-body markdown small">
                            Hier wird lediglich der Webserver virtualisiert und etwas Speicherplatz in
                            einer vorkonfigurierten Serverfarm angeboten. Die Einstellungsmöglichkeiten
                            sind sehr begrenzt und oft auf traditionelle Webanwendungen mit PHP als
                            Programmiersprache und MariaDB als Datenbank zugeschnitten.
                        </div>
                    </div>
                </div>

                <small>
                    <small>
                        ¹ Bildnachweis:
                        <a href="https://pixabay.com/photos/technology-servers-server-1587673/" target="_blank">Pixabay: heladodementa</a>
                    </small>
                </small>
            </section>

            <section data-title="Virtualisierung im Hosting" class="dhbw-limited-width2">
                <div class="dhbw-limited-width m-auto mb-5">
                    <div class="markdown mb-3 mt-3">
                        Um ökonomische Skaleneffekte auszunutzen, beruhen die meisten Hostingangebote auf
                        der Virtualisierung bestimmter Ressourcen, wobei der Begriff auf zwei Arten definiert
                        werden kann.
                    </div>
                    <lsx-accordion>
                        <lsx-accordion-page title="Virtualität im allgemein Wortsinn">
                            <blockquote class="blockquote">
                                <p class="small">
                                    Virtualität ist die Eigenschaft einer Sache, nicht in der Form zu existieren,
                                    in der sie zu existieren scheint, aber in ihrem Wesen oder ihrer Wirkung einer
                                    in dieser Form existierenden Sache zu gleichen. Virtualität bezeichnet also eine
                                    gedachte Entität, die in ihrer Funktionalität oder Wirkung vorhanden ist.
                                </p>
                                <figcaption class="blockquote-footer small">
                                    <cite>Wikipedia zum Begriff „Virtualität”</cite>
                                </figcaption>
                            </blockquote>
                        </lsx-accordion-page>
    
                        <lsx-accordion-page title="Virtualisierung in der Informatik">
                            <blockquote class="blockquote">
                                <p class="small">
                                    Virtualisierung bezeichnet in der Informatik die Nachbildung eines Hard- oder
                                    Software-Objekts durch ein ähnliches Objekt vom selben Typ mit Hilfe einer
                                    Abstraktionsschicht. Dadurch lassen sich virtuelle (d.&nbsp;h. nicht-physische)
                                    Geräte oder Dienste wie emulierte Hardware, Betriebssysteme, Datenspeicher oder
                                    Netzwerkressourcen erzeugen.
                                </p>
                                <figcaption class="blockquote-footer small">
                                    <cite>Wikipedia zum Begriff „Virtualisierung”</cite>
                                </figcaption>
                            </blockquote>
                        </lsx-accordion-page>
                    </lsx-accordion>
                </div>

                <div class="d-flex gap-3 flex-column flex-md-row">
                    <div class="flex-grow-1 w-100 markdown small">
                        <img src="virtualisierung-hardware.png" class="w-100 mb-3" alt="Hardware-Virtualisierung">
                        
                        Virtualisierte Hardware bietet die größte Flexibilität, da sie sich aus Kundensicht
                        wie dedizierte Hardware verhält. Der Kunde mietet zwar keinen physischen Computer,
                        kann aber dennoch beliebige Software aufspielen.
                    </div>
                    <div class="flex-grow-1 w-100 markdown small">
                        <img src="virtualisierung-betriebssystem.png" class="w-100 mb-3" alt="Betriebssystem-Virtualisierung">
                        
                        Preisgünstigere Angebote virtualisieren in der Regel nur das Betriebssystem, wodurch
                        mehr Kunden bedient werden können. Die Installation beschränkt sich daher auf kompatible
                        Systemumgebungen und Anwendungen.
                    </div>
                    <div class="flex-grow-1 w-100 markdown small">
                        <img src="virtualisierung-server.png" class="w-100 mb-3" alt="Server-Virtualisierung">
                        
                        Einfache Hostingangebote virtualisieren lediglich die Serveranwendung. Die Kunden bekommen
                        eine eigene Domain und etwas Speicherplatz mit sehr beschränkten Einstellungsmöglichkeiten.
                    </div>
                </div>

                <small>
                    <small>
                        Bildnachweise:
                        <a href="https://de.wikipedia.org/wiki/Datei:Apache_Feather_Logo.svg" target="_blank">Wikipedia: Apache_Feather_Logo.svg</a>,
                        <a href="https://de.m.wikipedia.org/wiki/Datei:Tux.svg" target="_blank">Wikipedia: Tux.svg</a>,
                        <a href="https://commons.wikimedia.org/wiki/File:Daemon-phk.svg" target="_blank">Wikipedia: Daemon-phk.svg</a>,
                        <a href="https://de.m.wikipedia.org/wiki/Datei:Windows_logo_-_2012.svg" target="_blank">Wikipedia: Windows logo - 2012.svg</a>,
                        <a href="https://icon-icons.com/de/symbol/tux-logo/214728" target="_blank">icon-icons.com: Tux Logo</a>
                    </small>
                </small>
            </section>

            <section data-title="Grundidee der Cloud" class="mb-3">
                <lsx-grid-fluid class="p-0">
                    <lsx-row>
                        <lsx-col size="md-9" class="mb-3">
                            <img src="cloud-betriebsmodell.png" class="d-block w-100" />
                        </lsx-col>
                        <lsx-col size="md" class="d-flex flex-column gap-3">
                            <div class="card">
                                <div class="card-header fw-bold">
                                    Automatisierung
                                </div>
                                <div class="card-body markdown small">
                                    Die Grundidee der Cloud ist, die Bereitstellung und den Betrieb verteilter
                                    Anwendungen so weit wie möglich zu automatisieren. Eine Cloudumgebung besteht
                                    daher aus einem großen Rechencluster, dessen Ressourcen auf viele Anwendungen
                                    aufgeteilt werden. Manuelle Installationsschritte sollen vermieden werden.
                                    {.mb-0}
                                </div>
                            </div>

                            <div class="card">
                                <div class="card-header fw-bold">
                                    Isolation
                                </div>
                                <div class="card-body markdown small">
                                    Die physischen und virtuellen Maschinen sowie Speicherressourcen einer Cloudumgebung
                                    werden vollständig abstrahiert, wodurch jede Anwendung einen eigenen, **virtuellen
                                    Computercluster** erhält. Häufig (aber nicht immer) wird dabei auch das Netzwerk
                                    virtualisiert, wodurch interne Services in einem **privaten Netzwerk** vor öffentlichen
                                    Zugriffen geschützt werden können.
                                    {.mb-0}
                                </div>
                            </div>

                            <div class="card">
                                <div class="card-header fw-bold">
                                    Skalierung und Elastizität
                                </div>
                                <div class="card-body markdown small">
                                    **Skalierung** beschreibt die Anpassung der zur Verfügung gestellten Ressourcen
                                    entsprechend dem Leistungsbedarf einer Anwendung. Beim klassischen Hosting und
                                    bei sehr einfachen Cloud-Installationen ist dies nur durch manuelles Eingreifen
                                    möglich. Echte Cloud-Anwendungen sind jedoch **elastisch**, so dass der Cluster
                                    die Ressourcen automatisch skalieren kann.
                                    {.mb-0}
                                </div>
                            </div>

                            <div class="card">
                                <div class="card-header fw-bold">
                                    Variable Kosten
                                </div>
                                <div class="card-body markdown small">
                                    Aufgrund der dynamischen Ressourcenzuteilung bieten viele Cloud-Angebote eine
                                    **nutzungsabhängige Abrechnung**, die sich nach Anzahl der tatsächlich genutzten
                                    Minuten zur Ausführung von Programmcode, tatsächlich belegtem Speicherplatz
                                    oder Netzwerktraffic richtet. Im Vergleich zu klassischem Hosting fallen die
                                    durchschnittlichen Kosten daher oft geringer aus.
                                    {.mb-0}
                                </div>
                            </div>
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </section>

            <section data-title="Pet vs. Cattle" class="dhbw-limited-width2">
                <div class="d-flex gap-3 flex-column flex-md-row">
                    <div class="card flex-grow-1 w-100">
                        <img src="pet-vs-cattle-1.jpg" class="card-img-top">
                        <div class="card-header border-top fw-bold">
                            Hosting
                        </div>
                        <div class="card-body small">
                            Die Software wird gehegt und gepflegt wie ein Haustier.
                        </div>
                    </div>
                
                    <div class="card flex-grow-1 w-100">
                        <img src="pet-vs-cattle-2.jpg" class="card-img-top">
                        <div class="card-header border-top fw-bold">
                            Cloud
                        </div>
                        <div class="card-body small">
                            Die Software wird wie Vieh in der Massentierhaltung behandelt.
                        </div>
                    </div>
                </div>

                <small>
                    <small>
                        Bildnachweise:
                        <a href="https://pixabay.com/photos/children-dog-pet-cute-footwear-1866531/" target="_blank">Pixabay: Pexels</a>,
                        <a href="https://pixabay.com/photos/sheeps-animals-mammals-live-stock-6828766/" target="_blank">Pixabay: smoms_photography</a>
                    </small>
                </small>
            </section>

            <section data-title="Das As-a-Service-Geschäftsmodell" class="dhbw-limited-width2">
                <div class="markdown mt-3 mb-5">
                    Cloudangebote werden häufig mit dem Namenszusatz „as-a-Service” angeboten,
                    wie beispielsweise „Database-as-a-Service“ oder „Software-as-a-Service".
                    Damit ist gemeint, dass die jeweilige Software **nicht klassisch lizenziert,
                    sondern als Dienstleistung** vermarktet wird. Installation, Betrieb und Pflege
                    werden fallen in die Verantwortung des Anbieters, wodurch diese aus Kundensicht
                    komplett ausgelagert werden können.
                </div>

                <div class="d-flex gap-3 flex-column flex-md-row mb-4">
                    <div class="flex-grow-1 w-100 markdown small">
                        ### Infrastructure-as-a-Service {.mb-3}

                        <img src="modelle-iaas.png" class="w-100 mb-3">
                
                        Im einfachsten Fall stellt die Cloud virtuelle Maschinen zur manuellen Einrichtung
                        sowie dazugehörige Dienste wie Objektspeicher und Netzwerkrouting zur Verfügung.
                        Lediglich die Bereitstellung aus Sicht des Cloudanbieters wird dabei automatisiert.
                    </div>
                    <div class="flex-grow-1 w-100 markdown small">
                        ### Platform-as-a-Service {.mb-3}

                        <img src="modelle-paas.png" class="w-100 mb-3">
                
                        Auf die Entwicklung von Cloudanwendungen zugeschnittene Angebote bieten eine
                        vorkonfigurierte Laufzeitumgebung für selbstgeschriebenen Quellcode. Deployment
                        und Betrieb werden weitgehend automatisiert. Es besteht jedoch die Gefahr von
                        Vendor Lock-In aufgrund der Verwendung anbieterspezifischer Bibliotheken.
                    </div>
                    <div class="flex-grow-1 w-100 markdown small">
                        ### Software-as-a-Service {.mb-3}

                        <img src="modelle-saas.png" class="w-100 mb-3">
                
                        Am weitesten abstrahiert sind SaaS-Angebote zur Bereitstellung ganzer Anwendungspakete.
                        Als Kunde registriert man sich lediglich für eine Anwendung, die gegen eine monatliche
                        Gebühr zur Verfügung gestellt wird. Alle Kunden teilen sich meist den Quellcode, während
                        die Daten getrennt werden.
                    </div>
                </div>

                <div class="markdown">
                    Angebote wie **Function-as-a-Service** (auch **Serverless** genannt, da die Verwaltung von Serverinstanzen komplett
                    wegabstrahiert wird) oder **Database-as-a-Service** richten ebenfalls an Anwendungsentwickler und zählen deshalb zu
                    Platform-as-a-Service.
                    
                    Die großen Anbieter wie Amazon, Google oder Microsoft bieten grundsätzlich eine Mischung aus allen Modellen, während
                    sich kleinere Anbieter wie [Heroku](https://heroku.com/){target="_blank"}, [Render](https://render.com/){target="_blank"},
                    [Fly.io](https://fly.io/){target="_blank"} meist auf Plattformdienste beschränken.
                    [MongoDB Atlas](https://www.mongodb.com/de-de/atlas){target="_blank"}, [Auth0](https://auth0.com/){target="_blank"}
                    und viele mehr zielen hingegen auf ganz spezielle Anwendungsfälle ab.
                </div>
            </section>

            <section data-title="Container-Virtualisierung in der Cloud" class="w-100">
                <div class="dhbw-limited-width2 d-flex flex-column flex-lg-row align-items-center gap-3 m-auto mt-3 mb-4">
                    <img src="virtualisierung-container.png" class="d-block" style="width: 24em; max-width: 100%;">
                    <div class="markdown flex-grow-1">
                        Viele Cloudumgebungen nutzen Container-Virtualisierung, um beliebige Workloads ausführen zu können.
                        Die auszuführenden Anwendungen und Services werden hierfür in **Anwendungscontainer** verpackt, die ein
                        **sehr abgespecktes Dateisystem** mit den notwendigsten **Bibliotheken**, **Hilfsprogrammen** sowie
                        dem **Anwendungscode** beinhalten und somit das zugrunde liegende Linux-System **wegabstrahieren**.
                        Der Anwendung wird dadurch vorgetäuscht, sie sei die einzige innerhalb des Host-Betriebssystems
                        ausgeführte Anwendung, was **Isolation** genannt wird.

                        Hierbei wird zwischen Container-Abbild (Image) und Container-Instanz unterschieden:

                         * **Image:** Binärpaket, das innerhalb der Cloud deployed werden kann
                         * **Instanz:** Tatsächlich ausgeführter Container auf einem Rechnerknoten
                        
                        Die Erstellung der Images wird grundsätzlich automatisiert. Unterschiede bestehen lediglich in
                        den verwendeten Werkzeugen und den hierfür benötigten Konfigurationsdateien. Typische Quellcodes einer
                        bestimmten Programmiersprache können häufig ohne Konfiguration direkt deployed werden, wobei ein in der
                        Cloud laufendes **Buildpack** diese in Anwendungscontainer verpackt. Meist kann der Prozess durch
                        zusätzliche Konfigurationsdateien beeinflusst werden, wenn man die Container nicht alternativ selbst baut. {.mb-0}
                    </div>
                </div>
                
                <div class="dhbw-limited-width2 m-auto mb-5 markdown">
                    Das folgende Beispiel zeigt einen typischen **DevOps-Workflow**, bei dem die Anwendungscontainer durch eine
                    Continous-Integration/Continous-Deployment-Pipeline automatisiert gebaut, in einer Container-Registrierung
                    abgelegt und anschließend in der Cloud deployed werden.
                </div>
                <img src="devops.png" class="img-fluid w-100">
            </section>

            <!-- ================================== -->
            <!-- Verteilte Anwendungen in der Cloud -->
            <!-- ================================== -->
            <section data-title="Verteilte Anwendungen in der Cloud" data-chapter></section>
            <section data-title="Verteilte Anwendungen in der Cloud" data-background-image="../trennfolie.jpg"></section>

            <section data-title="Anwendungsarchitektur früher">
                <lsx-grid-fluid class="p-0">
                    <lsx-row>
                        <lsx-col size="md-8" class="mb-3">
                            <img src="monolith.png" class="d-block w-100" />
                        </lsx-col>
                        <lsx-col size="md" class="markdown">
                            Frühere Anwendungsarchitekturen, bei denen sämtliche Funktionen in einer großen Codebasis
                            untergebracht waren, werden heute als **Monolith** bezeichnet. Zwar kann der Quellcode
                            durchaus modular aufgebaut und somit leicht um neue Funktionen erweiterbar sein. Jedoch
                            kann die Anwendung nur als Ganzes deployed und in Betrieb genommen werden.

                            ### Vorteile eines Monolithen {.mt-4}

                            * Einfache Anwendungsarchitektur mit wenigen Komponenten
                            * Insbesondere für kleine Entwicklerteams leicht handlebar
                            * Eine Programmiersprache für alle Teile der Anwendung
                            * Direkter Datenaustausch zwischen den Anwendungskomponenten
                            * Anwendungskomponenten können sich gegenseitig direkt aufrufen

                            ### Nachteile eines Monolithen {.mt-4}

                            * Unpraktisch für sehr große Anwendungen mit vielen Funktionen
                            * Auswirkungen einer Quellcodeänderung sind oft schwer nachvollziehbar
                            * In großen Entwicklerteams kommt es oft zu gegenseitigen Störungen
                            * Kein getrenntes Deployment einzelner Anwendungsfunktionen möglich
                            * Vor jedem Deployment muss die komplette Anwendung getestet werden
                            * Fehlerkorrekturen brauchen daher oft lange, bis sie produktiv gehen
                            * Die Anwendung kann nur als Ganzes skaliert werden

                            Cloudanwendungen werden daher häufig mit einer *Microservice-Architektur* gestaltet.
                            Für kleine Entwicklerteams kann ein Monolith trotzdem die bessere Wahl sein. {.mt-4}
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </section>

            <section data-title="Probleme beim Deployment monolithischer Anwendungen" class="dhbw-limited-width2 p-3">
                <div class="d-flex flex-column flex-md-row gap-5">
                    <img src="wanted-monolith.jpg" class="d-block w-100" alt="Wanted! The Monolith …">
                    <img src="code-freeze.jpg" class="d-block w-100" alt="It's really, really, really, really code freeze">
                </div>

                <small>
                    <small>
                        Bildnachweise:
                        <a href="https://turnoff.us/geek/not-wanted/" target="_blank">{turnoff.us} not wanted</a>,
                        <a href="https://geek-and-poke.com/geekandpoke/2015/3/25/code-freeze" target="_blank">Geek & Poke: Code Freeze</a>
                    </small>
                </small>
            </section>

            <section data-title="Anwendungsarchitektur heute">
                <lsx-grid-fluid class="p-0 mt-3">
                    <lsx-row>
                        <lsx-col size="md-8" class="mb-3">
                            <div class="dropdown mb-3">
                                <button
                                    id             = "microservices-dropdown"
                                    class          = "btn btn-outline-secondary dropdown-toggle"
                                    style          = "font-size: 0.9rem;"
                                    type           = "button"
                                    data-bs-toggle = "dropdown"
                                    aria-haspopup  = "true"
                                    aria-expanded  = "false"
                                >
                                    Single Page App mit API-Gateway
                                </button>
                                <ul class="dropdown-menu">
                                    <li>
                                        <button
                                            class          = "dropdown-item"
                                            type           = "button"
                                            data-dropdown  = "#microservices-dropdown"
                                            data-container = "#microservices-bilder"
                                            data-show      = "#microservices-bilder-1"
                                            onclick        = "change_example(event)"
                                        >
                                            Single Page App mit API-Gateway
                                        </button>
                                    </li>
                                    <li>
                                        <button
                                            class          = "dropdown-item"
                                            type           = "button"
                                            data-dropdown  = "#microservices-dropdown"
                                            data-container = "#microservices-bilder"
                                            data-show      = "#microservices-bilder-2"
                                            onclick        = "change_example(event)"
                                        >
                                            Webanwendung mit Composite UI
                                        </button>
                                    </li>
                                </ul>
                            </div>

                            <div id="microservices-bilder">
                                <img id="microservices-bilder-1" src="microservices-gateway.png" class="d-block w-100" />
                                <img id="microservices-bilder-2" src="microservices-compositeui.png" class="d-block w-100 hidden" />
                            </div>
                        </lsx-col>
                        <lsx-col size="md" class="markdown">
                            Moderne Anwendungen werden heute oft als **Microservice-Architektur** ausgeführt, in welcher die
                            Teilfunktionen einer Anwendung in einzelne Serverdienste ausgelagert werden. Microservice-basierte
                            Anwendungen sind daher immer verteilte Anwendungen. Dabei bildet jeder Microservice eine getrennte
                            Einheit, die weitgehend unabhängig entwickelt, deployed und betrieben wird. Meistens besitzt jeder
                            Microservice deshalb eine eigene Datenbank, auf deren Inhalte nur über die öffentliche Schnittstelle
                            des Microservices entfernt zugegriffen werden kann. Martin Fowler definiert Microservices
                            [auf seiner Webseite](https://martinfowler.com/microservices/){target=_blank} daher wie folgt:

                            * Entfernte Serverdienste als Teilkomponenten einer Anwendung
                            * Dezentralisierte Verwaltung und dezentrales Datenmanagement
                            * Entsprechen oft organisatorischer Unternehmenseinheiten
                            * Deshalb meist langfristig durch eigenständige Teams betreut
                            * Über eine öffentliche Schnittstelle entfernt aufrufbar
                            * Fehlertoleranter Entwurf mit evolutionärem Design
                            * Hoher Automatisierungsgrad für Betrieb und Weiterentwicklung

                            Die öffentliche Benutzeroberfläche einer Microservice-basierten Anwendung wird häufig als **Webanwendung**
                            oder **Mobile App** implementiert, wobei Webanwendungen zunehmend Single Page Apps sind, deren generelle
                            Anwendungslogik zwar im Browser läuft. Ein **Gateway-Server** versteckt dann in der Regel die einzelnen
                            Backend-Services vor dem Frontend. Alternativ können die Microservices aber auch so genannte **Microfrontends**
                            bereitstellen, die jeweils einen Ausschnitt der darzustellenden Bildschirminhalte liefern und nach dem
                            **Composite UI Pattern** innerhalb eines Anwendungsrahmens eingeblendet werden.

                            ### Vorteile von Microservices {.mt-4}

                            * Die Services sind durch ihre Schnittstellen klar gekapselt.
                            * Jeder Service kann einzeln deployed und skaliert werden.
                            * Sprachen, Bibliotheken, … können passend zum Service ausgewählt werden.

                            ### Nachteile von Microservices {.mt-4}

                            * Verteilte Systeme mit vielen Komponenten sind schwer zu programmieren.
                            * Microservices müssen eventuellkonsistent und fehlertolerant programmiert werden.
                            * Deployment, Betrieb und Überwachung bringen zusätzliche Komplexität.

                            Laut Martin Fowler lohnt sich eine Microservice-Architektur daher nur, wenn eine Anwendung hinreichend
                            groß ist und von mehreren Entwicklerteams betreut werden kann. Vgl.
                            [Martin Fowler: Microservice Guide](https://martinfowler.com/microservices/){target=_blank}
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </section>

            <section data-title="Herausforderungen bei der Nutzung von Microservices" class="dhbw-limited-width2 p-3">
                <div class="d-flex flex-column flex-md-row gap-3">
                    <img src="valentines-day.png" class="d-block w-100" alt="Happy Valentines Day">
                    <img src="microservices-and-monolithic.png" class="d-block w-100" alt="Are you ready for microservices?">
                </div>
            
                <small>
                    <small>
                        Bildnachweise:
                        <a href="https://turnoff.us/geek/valentines-day/" target="_blank">{turnoff.us} valentine's day at the kernel</a>,
                        <a href="https://turnoff.us/geek/are-you-ready-for-microservices/" target="_blank">{turnoff.us} are you ready for microservices?</a>
                    </small>
                </small>
            </section>

            <section data-title="Skalierung von Microservices" class="dhbw-limited-width2">
                <lsx-carousel class="carousel-fade">
                    <lsx-carousel-page>
                        <img src="skalierung-1.png" class="d-block w-100 mb-5">
                        <p>
                            Microservice-Architekturen lassen sich grundsätzlich einfacher skalieren als monolithische Anwendungen,
                            da jeder Service getrennt deployed wird. Für jeden Service kann daher eine optimale Ressourcenzuteilung
                            entsprechend dem tatsächlichen Bedarf vorgenommen werden.
                        </p>
                    </lsx-carousel-page>
                    <lsx-carousel-page>
                        <img src="skalierung-2.png" class="d-block w-100 mb-5">
                        <p>
                            Bei leicht ansteigender Last könnte die Cloudumgebung beispielsweise den laufenden Instanzen mehr
                            Leistung zur Verfügung stellen.
                        </p>
                    </lsx-carousel-page>
                    <lsx-carousel-page>
                        <img src="skalierung-3.png" class="d-block w-100 mb-5">
                        <p>
                            In der Regel werden so genannte Skalierungstrigger, wie die Anzahl HTTP-Anfragen je Sekunde, jedoch
                            genutzt, um weitere Serviceinstanzen zu starten. Die eingehenden Anfragen werden dann durch einen Load
                            Balancer gleichmäßig auf die Instanzen verteilt.
                        </p>
                    </lsx-carousel-page>
                    <lsx-carousel-page>
                        <img src="skalierung-4.png" class="d-block w-100 mb-5">
                        <p>
                            Damit diese Art der Skalierung funktioniert, dürfen die Services allerdings keine temporären Sitzungdaten
                            im Hauptspeicher ablegen. Denn es kann in der Regel nicht garantiert werden, dass zusammengehörige Anfragen
                            stets dieselbe Instanz erreichen. Außerdem können die Instanzen jederzeit neugestartet werden, wodurch die
                            im Hauptspeicher liegenden Daten ebenfalls verloren gingen.
                        </p>
                    </lsx-carousel-page>
                    <lsx-carousel-page>
                        <img src="skalierung-5.png" class="d-block w-100 mb-5">
                        <p>
                            Cloud-Anwendungen, welche serverseitige Sitzungsdaten verwalten, persistieren diese daher meist in einer
                            Datenbank. Oft wird hierfür dieselbe Datenbank genutzt, in der auch die originären Nutzdaten des jeweiligen
                            Microservices liegen. Genauso oft kommen allerdings auch spezialisierte Datenbanken oder Objektspeicher
                            wie Redis zum Einsatz.
                        </p>
                    </lsx-carousel-page>
                    <lsx-carousel-page>
                        <img src="skalierung-6.png" class="d-block w-100 mb-5">
                        <p>
                            Idealerweise benötigt eine Anwendung überhaupt keine serverseitigen Sitzungsdaten, sondern verwaltet diese
                            rein clientseitig. Dadurch werden der Server entlastet und Zeitverzögerungen aufgrund einer langsamen
                            Internetverbindung vermieden. Gemäß
                            <a href="https://martinfowler.com/articles/distributed-objects-microservices.html" target="_blank">Martin Fowler's „First Law of Distributed Objects”</a>
                            funktioniert dies am besten, wenn die Kommunikation mit dem Backend auf wenige Anfragen mit gebündelten
                            Inhalten reduziert wird.
                        </p>
                    </lsx-carousel-page>

                    <lsx-carousel-page>
                        <img class="active d-block w-25 m-auto" src="../finish.svg" />
                        <p>
                            Wird eine Anwendung nach den vorgenannten Prinzipien serverseitig möglichst zustandslos implementiert,
                            kann sie jederzeit problemlos hoch- oder runterskaliert werden.
                        </p>
                    </lsx-carousel-page>
                </lsx-carousel>
            </section>

            <section data-title="12-Faktor-Apps / Cloud Native Apps">
                <lsx-grid-fluid>
                    <lsx-row>
                        <lsx-col size="lg">
                            <img src="12factor.net.png" class="d-block w-100 dhbw-border">
                        </lsx-col>
                        <lsx-col size="lg">
                            <div class="markdown">
                                Eine elastische Skalierung setzt voraus, dass jederzeit weitere Instanzen eines Services gestartet
                                oder nicht mehr benötigte Instanzen gestoppt werden können. Um dies zu vereinfachen, haben die Macher
                                der Heroku-Cloud auf der Webseite [12factor.net](https://12factor.net){target=_blank} das 12-Faktor-Manifest
                                mit zwölf Regeln für **Cloud Native Apps** (auch **12-Faktor-Apps** genannt) veröffentlicht. Diese lassen
                                sich wie folgt zusammenfassen:
                            </div>

                            <lsx-tab-pages>
                                <lsx-tab-page title="Entwicklung">
                                    <div class="markdown">
                                        * Zentral verwalteter Quellcode
                                        * Abhängigkeiten explizit deklarieren
                                        * Getrennte Build-, Release- und Run-Phasen
                                        * Vergleichbare Entwicklungs- und Produktivumgebungen
            
                                        Microservices werden mit modernen Werkzeugen und modernen Programmierpraktiken entwickelt. Ihr Quellcode
                                        wird deshalb mit Werkzeugen wie Git versioniert, so dass jede Änderung daran nachvollziehbar ist. Werkzeuge
                                        wie `npm`, `pip` oder `maven` verwalten darüber hinaus die Abhängigkeiten zu externen Bibliotheken und sorgen
                                        für automatisierte Build- und Releaseprozesse.
                                        
                                        Zusätzlich finden Entwicklung und Test und vergleichbaren Bedingungen wie der spätere Produktiveinsatz statt,
                                        wofür die Produktivumgebung auf den Entwicklungs- und Testmaschinen so gut wie möglich nachgebildet wird.
                                    </div>
                                </lsx-tab-page>

                                <lsx-tab-page title="Konfiguration">
                                    <div class="markdown">
                                        * Nutzung fremder Dienste über das Netzwerk
                                        * Unterstützende Dienste sind Ressourcen
                                        * Konfiguration durch Umgebungsvariablen
                                        * Adminprozesse sind einmalige Vorgänge

                                        Microservices kommunizieren grundsätzlich über das Netzwerk bzw. das Internet mit anderen Microservices.
                                        Andere Schnittstellen sind nicht vorgesehen, um die Microservices auf getrennten virtuellen Maschinen und
                                        oft sogar getrennten physischen Maschinen betreiben zu können. Über die Konfiguration der Services, welche
                                        innerhalb der Cloudumgebung vorgenommen wird, werden jedem Microservice die Netzadressen der von ihm benötigten
                                        anderen Services mitgeteilt. Diese stehen dann zur Laufzeit als Umgebungsvariablen des Betriebssystems zur
                                        Verfügung, da es sich hierbei um eine universale, einfache Möglichkeit handelt.

                                        Falls administrative Aktionen wie die Reorganisation einer Datenbank oder das Löschen veralteter Daten
                                        notwendig sind, erfolgen diese durch einmalig aufgerufene, vom eigentlichen Microservice getrennt laufende
                                        Werkzeugprogramme.
                                    </div>
                                </lsx-tab-page>

                                <lsx-tab-page title="Ausführung">
                                    <div class="markdown">
                                        * Ausführung als einzelner Betriebssystemprozess
                                        * Parallelität durch weitere Betriebssystemprozesse
                                        * Robuster und schneller Start bzw. Stopp der Prozesse
                                        * Protokollierung durch zeitbezogene Ereignisse

                                        Microservices sind immer in sich geschlossen und bringen sämtliche Laufzeitumgebungen, Bibliotheken und
                                        Hilfsprogramme mit, um ausgeführt werden zu können. Sie können dadurch als einzelner Betriebssystemprozess
                                        leicht gestartet und gestoppt werden, beispielsweise indem sie in ein Container-Image verpackt werden.
                                        Start und Stopp müssen besonders schnell gehen, damit die Skalierung jederzeit elastisch angpasst werden
                                        kann.

                                        Für die Fehlersuche schreiben Microservices umfangreiche Protokollmeldungen in die Konsole (ihne Standardausgabe).
                                        Jede Meldung wird dabei mit einem eindeutigen Zeitstempel am Anfang versehen, so dass die Protokollmeldungen
                                        von der Cloud wie ein kontinuierlicher Datenstrom von zeitpunktbezogenen Ereignissen behandelt und archiviert
                                        werden können.
                                    </div>
                                </lsx-tab-page>
                            </lsx-tab-pages>
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </section>

            <section data-title="Fallbeispiel: Adressbuch">
                <div class="mb-3">
                    <lsx-github-edit url="https://github.com/DennisSchulmeister/dhbwka-wwi-vertsys-2022-quellcodes/tree/main/Beispielanwendung%20Adressbuch"></lsx-github-edit>
                </div>

                <div class="d-flex flex-column flex-md-row gap-3">
                    <img src="beispiel-adressbuch-1.png" class="img-thumbnail d-block w-100">
                    <img src="beispiel-adressbuch-2.png" class="img-thumbnail d-block w-100">
                    <img src="beispiel-adressbuch-3.png" class="img-thumbnail d-block w-100">
                </div>
            </section>

            <!-- ============================ -->
            <!-- Exkurs: Grundlagen zu Docker -->
            <!-- ============================ -->
            <section data-title="Exkurs: Grundlagen zu Docker" data-chapter></section>
            <section data-title="Exkurs: Grundlagen zu Docker" data-background-image="../trennfolie.jpg"></section>

            <section data-title="Was ist Docker?">
                <div class="markdown dhbw-limited-width m-auto mb-4">
                    Docker ist eine **Laufzeitumgebung zur Isolation laufender Prozesse**
                    unter Linux. (Aktuelle Versionen von Microsoft Windows unterstützen diese
                    Funktion inzwischen auch). Die Programme werden hierfür mit allen für ihre
                    Ausführung benötigten Systembibliotheken und Hilfsdateien in binäre Filesystem
                    Images (hier **Container Image** genannt) verpackt und dann durch den
                    Docker Daemon also sog. **Container** ausgeführt, wobei das Wort
                    Container hier die Isolation der Prozesse verdeutlichen soll.

                    Intern werden hierfür verschiedene Mechanismen des Linux-Kernels genutzt,
                    um den Programmen vorzugaukeln, dass sie die einzigen laufenden Programme
                    innerhalb des Betriebssystems wären. Gute Container Images starten daher
                    tatsächlich nur einen Prozess, der automatisch die **Prozess-ID 1**
                    bekommt.

                    Darüber hinaus virtualisiert Docker das Netzwerk sowie den Massenspeicher,
                    um die Container noch weiter voneinander zu isolieren. Zusammengehörige
                    Container können über ein **virtuelles Netzwerk** untereinander
                    kommunizieren und einzelne Ports können vom Host an die Container
                    weitergeleitet werden.

                    Wichtig zu verstehen ist, dass Container ,,immutabel'' sind, was bedeutet,
                    dass sie zwar Dateien in ihrem virtuellen Dateisystem erzeugen können,
                    diese bei einem Neustart des Containers aber verloren gehen. Über sog.
                    **Volumes** können stattdessen externe Massenspeicher angebunden
                    werden, um persistente Daten abzulegen.
                </div>

                <div class="d-flex align-items-stretch" style="gap: 1em;">
                    <img src="docker-1.png" class="d-block w-100 img-thumbnail"/>
                    <img src="docker-2.png" class="d-block w-100 img-thumbnail"/>
                </div>
            </section>

            <section data-title="Container Images bauen mit einem Dockerfile" class="limited-width">
                <div class="markdown">
                    Um ein sog. Image zu bauen, das von Docker als Container ausgeführt werden
                    kann, muss im Quellcode-Verzeichnis der Anwendung eine Datei namens
                    <span class="fn">Dockerfile</span> angelegt werden. Ihre Aufgabe ist zu
                    beschreiben, aus welchen Inhalten (also aus welchen Dateien) sich das Image
                    zusammensetzen soll.

                    Hierfür wird in der Regel aus dem „Docker Hub” (oft auch „Registry” genannt,
                    was aber nicht mit der „Node.js Registry” verwechselt werden darf) ein vorhandenes
                    Image referenziert und um eigene Dateien erweitert. Als Basis-Image kann dann
                    entweder ein minimales Betriebssystem-Image (z.B. Debian oder Alpine Linux)
                    oder eine vorkonfigurierte Laufzeitumgebung wie Node.js, Python, … (die selbst
                    auf einem der genannten Betriebssystem-Images basiert) ausgewählt werden.
                </div>

                <div class="card p-3 mt-3 mb-3 bg-light">
                    <table class="table table-striped">
                        <tr>
                            <td>
                                <src-code language="docker">FROM node:17-alpine</src-code>
                            </td>
                            <td>
                                Node.js 17.x als Basis-Image verwenden
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <src-code language="docker">ENV NODE_ENV=production HOST=::</src-code>
                            </td>
                            <td>
                                Zur Ausführung benötigte Umgebungsvariablen definieren
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <src-code language="docker">WORKDIR /app</src-code>
                            </td>
                            <td>
                                Wechseln des für die folgenden Befehle verwendeten Arbeitsverzeichnisses im Image
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <src-code language="docker">COPY package.json package-lock.json ./</src-code>
                            </td>
                            <td>
                                Quellcode-Dateien in das eben ausgewählte Arbeitsverzeichnis kopieren
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <src-code language="docker">RUN npm install</src-code>
                            </td>
                            <td>
                                Ausführen eines Befehls, um die benötigten Node.js-Module zu installieren
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <src-code language="docker">COPY src ./src</src-code>
                            </td>
                            <td>
                                Am Schluss den eigentlichen Quellcode in das Filesystem Image kopieren
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <src-code language="docker">EXPOSE 3000/tcp</src-code>
                            </td>
                            <td>
                                Dokumentieren, dass der Container auf TCP-Port 3000 einen Serverdienst bereitstellt
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <src-code language="docker">ENTRYPOINT ["node", "src/index.js"]</src-code>
                            </td>
                            <td>
                                Definition des zur Ausführung des Containers zu startenden Programms
                            </td>
                        </tr>
                    </table>
                </div>

                <p>
                    Die Reihenfolge der Anweisungen ist wichtig, da die meisten Anweisungen ein neues,
                    sog. „Filesystem Layer” erzeugen, in dem die durch die Anweisung verursachten
                    Änderungen an der Dateistruktur festgehalten werden. Indem sich weniger oft ändernde
                    Dateien an den Anfang gestellt werden, kann die Zeit zum Neubauen eines Containers
                    und die damit verbrauchte Bandbreite deutlich reduziert werden.
                </p>
            </section>

            <section data-title="Netzwerkvirtualisierung mit Docker" class="w-100">
                <div class="markdown">
                    * Standardmäßig werden Docker Container vollständig isoliert ausgeführt.
                    * Sie können zwar auf das Internet zugreifen, selbst aber keine Verbindungen entgegennehmen.
                    * Hierfür muss entweder eine Portweiterleitung oder ein virtuelles Netzwerk eingerichtet werden.
                    * Eine Portweiterleitung leitet an den Host gerichtete TCP-Anfragen an einen Container weiter.
                    * Ein virtuelles Netzwerk hingegen ermöglicht es mehreren Containern, untereinander zu kommunizieren.
                </div>

                <div class="d-flex align-items-stretch w-100" style="gap: 1em;">

                <div class="card w-100">
                    <div class="card-header fw-bold dhbw-lightblue">
                        Start eines Containers mit Portweiterleitung
                    </div>
                    <div class="card-body bg-light p-3">
                        <p>
                            <span class="cmd">docker run -d --name mongodb -p 27777:27017 mongo</span>
                        </p>
                        <table class="table table-striped">
                            <tr>
                                <td>
                                    <tt>docker run</tt>
                                </td>
                                <td>
                                    Subkommando zum Starten eines Containers
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <tt>-d</tt>
                                </td>
                                <td>
                                    Container im Hintergrund ausführen
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <tt>--name mongodb</tt>
                                </td>
                                <td>
                                    Festen Namen für den Container verwenden
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <tt>-p 27777:27017</tt>
                                </td>
                                <td>
                                    Anfragen an den TCP-Port 27777 des Hosts an Port 27017 des Containers weiterleiten
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <tt>mongo</tt>
                                </td>
                                <td>
                                    Name des auszuführenden Images
                                </td>
                            </tr>
                        </table>
                    </div>
                </div>

                <div class="card w-100">
                    <div class="card-header fw-bold dhbw-lightblue">
                        Verbinden mehrerer Container über ein virtuelles Netzwerk
                    </div>
                    <div class="card-body bg-light p-3">
                        <p>
                            <span class="cmd">docker net create beispiel</span> <br />
                            Virtuelles Netzwerk mit dem Namen <span class="cmd">beispiel</span> erzeugen
                        </p>
                        <p>
                            <span class="cmd">docker run -d --name mongodb --net beispiel mongo</span> <br />
                            Container im Hintergrund starten und diesen mit dem Beispiel-Netzwerk verbinden.
                            Über das virtuelle Netzwerk können die im Container laufenden Serverdienste
                            aufgerufen werden. Von Außen ist der Container allerdings nicht erreichbar.
                        </p>
                        <p>
                            <span class="cmd">docker run -d --name backend --net beispiel -p 3000:3000 adressbuch-backend</span> <br />
                            Weiteren Container starten und sowohl mit dem Beispiel-Netzwerk verbinden als
                            auch eine Portweiterleitung definieren. Warum? Weil das Backend unserer Anwendung
                            vom Browser aus aufrufbar sein muss, über das virtuelle Netzwerk jedoch auch mit der
                            Datenbank kommunizieren soll.
                        </p>

                        <h3>Service Discovery</h3>
                        <p>
                            Über den Domainnamen <span class="fn">mongo</span> kann der
                            Backend-Service die interne IP-Adresse des Datenbank-Containers ermitteln.
                        </p>

                        <h3>Load Balancing</h3>
                        <p>
                            Wurden mehrere Instanzen des Datenbank-Containers gestartet, verteilt
                            Docker die Anfragen automatisch auf die unterschiedlichen Instanzen,
                            indem es bei jedem DNS Lookup die IP-Adresse einer anderen Instanz
                            zurück liefert.
                        </p>
                    </div>
                </div>

                </div>
            </section>

            <section data-title="Mehrere Container orchestrieren mit Docker Compose" style="width: 70em;">
                <div class="markdown">
                    Da die Befehlsketten zur Ausführung und Verknüpfung mehrerer Docker-Container
                    mitunter sehr komplex werden können, lässt sich ein Setup aus zusammehängenden
                    Containern auch deklarativ in einer Datei namens <span class="fn">docker-compose.yml</span>
                    beschreiben. Das Werkzeug **Docker Compose** übernimmt dann den Start und auch die
                    Beendigung aller Container in der richtigen Reihenfolge. Außerdem kann damit eine
                    einfache Skalierung durch Starten mehrerer, paralleler Containerinstanzen erreicht
                    werden. Mit **Docker Swarm** kann eine so definierte Anwendung auch ganz einfach
                    in einem Cluster produktiv deployed werden.
                </div>

                <div class="card p-3 mt-3 mb-3 bg-light">
                    <table class="table table-striped">
                        <tr>
                            <td>
                                <source-code language="yaml">
                                    version: "3.9"
                                </source-code>
                            </td>
                            <td>
                                Definition der Version des Docker-Compose-Dateiformats
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <source-code language="yaml">
                                    volumes:
                                        dbdata:
                                        dbconfig:
                                </source-code>
                            </td>
                            <td>
                                Aufzählung von sog. Volumes zur Ablage persistenter Daten
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <source-code language="yaml">
                                    services:
                                </source-code>
                            </td>
                            <td>
                                Beginn der Service-Definitionen mit den zu startenden Containern
                            </td>
                        </tr>
                        <tr>
                            <td style="padding-left: 3em;">
                                <source-code language="yaml">
                                        # MongoDB-Datenbank
                                        mongodb:
                                            image: mongo
                                            restart: always
                                            environment:
                                                MONGO_INITDB_ROOT_USERNAME: dbuser
                                                MONGO_INITDB_ROOT_PASSWORD: dbpass
                                            volumes:
                                                - dbdata:/data/db
                                                - dbconfig:/data/configdb
                                </source-code>
                            </td>
                            <td>
                                <p>
                                    Definition des Containers <span class="scr">mongodb</span> zur Ausführung
                                    des Images <span class="scr">mongo</span> aus dem Docker Hub.
                                </p>
                                <p>
                                    Bei einem Absturz wird der Container automatisch neugestartet (Resilienz).
                                </p>
                                <p>
                                    Im Container werden zwei Umgebungsvariablen mit Konfigurationswerten für
                                    einen beim ersten Start anzulegenden Admin-Benutzer definiert.
                                </p>
                                <p>
                                    Durch die oben benannten Volumes werden die Inhalte der beiden Verzeichnisse
                                    <span class="fn">/data/db</span> und <span class="fn">/data/configdb</span>
                                    mit dem Host geteilt und bleiben somit nach einem Neustart des Containers
                                    erhalten.
                                </p>
                            </td>
                        </tr>
                        <tr>
                            <td style="padding-left: 3em;">
                                <source-code language="yaml">
                                    # Adressbuch-Backend (Produktivmodus)
                                    backend:
                                        build:
                                            context: ./Backend
                                        depends_on:
                                            - mongodb
                                        restart: always
                                        environment:
                                            HOST: "::"
                                            PORT: 3000
                                            MONGODB: mongodb://dbuser:dbpass@mongodb:27017/
                                        deploy:
                                            replicas: 3
                                </source-code>
                            </td>
                            <td>
                                <p>
                                    Definition des Containers <span class="scr">backend</span>, der aus dem
                                    <span class="fn">Dockerfile</span> im Unterverzeichnis <span class="fn">Backend</span>
                                    gebaut wird.
                                </p>
                                <p>
                                    Der Container kann erst gestartet werden, wenn der Container mit dem Namen
                                    <span class="scr">mongodb</span> läuft.
                                </p>
                                <p>
                                    Bei einem Absturz wird der Container automatisch neugestartet (Resilienz).
                                </p>
                                <p>
                                    Im Container werden drei Umgebungsvariablen mit den Verbindungsdaten zur
                                    Mongo-Datenbank definiert.
                                </p>
                                <p>
                                    Standardmäßig werden drei Instanzen des Containers gestartet.
                                </p>
                            </td>
                        </tr>
                    </table>
                </div>
            </section>

            <section data-title="Typische Befehle zur Verwendung von Docker" class="markdown limited-width">
                ### Docker CLI

                * <span class="cmd">docker help</span>: <br />
                  Hilfe! 🤕

                * <span class="cmd">docker &lt;kommando&gt; help</span>: <br />
                  Hilfe zu einem Docker-Subkommando

                * <span class="cmd">docker run -d &lt;container&gt;</span>: <br />
                  Start eines Containers im Hintergrund

                * <span class="cmd">docker run -it &lt;container&gt; &lt;befehl&gt;</span>: <br />
                  Ausführen eines interaktiven Befehls in einem neuen Container

                * <span class="cmd">docker container ls</span>: <br />
                  Alle laufenden Container anzeigen

                * <span class="cmd">docker container stop &lt;name&gt;</span> <br />
                  Beenden eines laufenden Containers

                * <span class="cmd">docker logs &lt;name&gt;</span> <br />
                  Konsolen- und Log-Ausgaben eines Containers zeigen

                * <span class="cmd">docker net create &lt;netwerk&gt;</span> <br />
                  Neues, virtuelles Netzwerk zur Kommunikation mehrerer Container untereinander erstellen

                * <span class="cmd">docker system prune</span> <br />
                  Nicht mehr benötigte Ressourcen freigeben (wichtig!)

                * <span class="cmd">docker volume prune</span> <br />
                  Nicht mehr verwendete Volumes löschen, da diese sehr viel Speicher belegen können.

                  <lsx-info-box type="warning" title="Achtung, Datenverlust!">
                      Es werden alle Volumes gelöscht, die aktuell von keinem laufenden Container
                      genutzt werden. Dadurch sind ggf. dann auch die persistenten Daten der MongoDB
                      weg, wenn diese bei Ausführung des Befehls gerade nicht läuft.
                  </lsx-info-box>

                ### Docker Compose {.mt-5}

                * <span class="cmd">docker compose up</span>:  <br />
                  Start mehrerer zusammengehöriger Docker Container **im Vordergrund**

                * <span class="cmd">docker compose up -d</span>: <br />
                  Start mehrerer zusammengehöriger Docker Container **im Hintergrund**

                * <span class="cmd">docker compose down</span>:  <br />
                  Stoppen der mit Docker Compose gestarteten Container

                * <span class="cmd">docker compose build</span>:  <br />
                  Neubauen aller Container Images anhand ihres <span class="fn">Dockerfile</span>
            </section>

            <section data-title="Aufgabe: Wir erkunden Docker (30 Minuten)" class="markdown limited-width" data-background-color="rgb(231, 221, 141)">
                Öffnen Sie den folgenden Link zum Starten der GitPod Online IDE mit den Quellcodes
                zur Vorlesung. Neben einem an Visual Studio Code angelehnten Code-Editor und einer
                Linux-Umgebung mit Node.js und anderen Werkzeugen, stellt diese Ihnen auch Docker
                und Docker Compose zur Verfügung. Sie können somit Docker ausprobieren oder gar am
                Portfolioprojekt der Vorlesung arbeiten, ohne etwas auf Ihrem Rechner installieren
                zu müssen. Im Gegenzug benötigen Sie allerdings eine dauerhafte Internetverbindung,
                um programmieren zu können.

                <a href="https://www.gitpod.io/#https://github.com/DennisSchulmeister/dhbwka-wwi-vertsys-2022-quellcodes" target="_blank" class="fw-bold">Online IDE: Quellcodes zur Vorlesung</a>

                ![Gitpod](docker-aufgabe-gitpod.png){.img-thumbnail img-responsive}

                Falls noch nicht geschehen, öffnen Sie über das Hamburger-Menü oben links ein
                neues Terminal. In diesem Wechseln Sie mit dem <span class="cmd">cd</span>-Befehl
                in das Adressbuch-Beispiel:

                <span class="cmd">cd Beispielanwendung\ Adressbuch</span>

                Um nicht den gesamten Befehl eintippen zu müssen, genügt es, wenn Sie nur die
                ersten paar Buchstaben tippen und dann die <kbd>Tab</kbd>-Taste drücken, um
                die sog. „Command Completion” der Konsole auszuführen. Da es mehrere Verzeichnisse
                mit dem Wort „Beispielanwendung” am Anfang gibt, drücken Sie anschließend
                <kbd>A</kbd> und dann wieder <kbd>Tab</kbd>, damit sich der Befehl vervollständigt.

                Das Tolle an GitPod ist, dass innerhalb des Terminals ausgeführte Serverdienste
                wie z.B. der Backend-Service der Anwendung über eine öffentliche URL testbar
                gemacht werden. Dies benötigen wir, damit die Frontend-Anwendung (die ja innerhalb
                des Browsers und somit nicht in der Linux-Umgebung der IDE läuft) auf das Backend
                zugreifen kann. Im ersten Schritt geht es daher darum, die URL des Backend-Services
                zu ermitteln und in der Umgebungsvariable `API_KEY` abzulegen. Gehen Sie hierfür
                wie folgt vor:

                 1. Starten Sie alle Container mit dem Befehl <br />
                   <span class="cmd">docker-compose -f docker-compose.dev.yml up -d</span>

                 1. Öffnen Sie links in der Sidebar den „Remote Explorer”.

                 1. Schalten Sie alle Ports frei, um eine öffentliche URL zu erzeugen.

                 1. Öffnen Sie die Vorschau für den Port 3000.

                 1. Kopieren Sie sich die URL des Services aus dem Vorschaufenster.

                 1. Erzeugen Sie die Umgebungsvariable im Terminal mit folgendem Befehl: <br />
                    <span class="cmd">export API_URL=https://3000-….gitpod.io</span>

                 1. Starten Sie anschließend mit folgenden Befehlen alle Container neu: <br />
                    <span class="cmd">docker-compose -f docker-compose.dev.yml down</span> <br />
                    <span class="cmd">docker-compose -f docker-compose.dev.yml up -d</span> <br />

                 1. Öffnen Sie anschließend die Vorschau für den Remote Port 8080.
                    Wenn Sie wollen können Sie die URL aus dem Vorschaufenster in
                    einen neuen Browser-Tab einfügen. Auf jeden Fall testen Sie, ob
                    sich die App fehlerfrei bedienen lässt.

                Nehmen Sie nun eine Änderung am Backend-Quellcode vor und laden
                Sie die Vorschauseite neu. Beobachten Sie dabei, dass die
                Änderung sofort aktiv wurde. Anschließend nehmen Sie eine
                Änderung am Frontend-Quellcode vor und laden Sie Vorschseite
                wieder neu. Beobachten Sie auch hier, dass die Änderung ohne
                manuelles Eingreifen sofort aktiv wurde.

                Versuchen Sie abschließend, mit der Datei <span class="fn">docker-compose.prod.yml</span>
                die Produktivversion der Anwendung zu starten. Verschen Sie dann,
                die in der Entwicklungsversion definierte Mongo-Admin-Oberfläche
                in die Produktiversion aufzunehmen. Welche Schritte sind hierfür
                notwendig?
            </section>
            
            <!-- =========================== -->
            <!-- Architekturmuster im Detail -->
            <!-- =========================== -->
            <section data-title="Architekturmuster im Detail" data-chapter></section>
            <section data-title="Architekturmuster im Detail" data-background-image="../trennfolie.jpg"></section>

            <section data-title="Übersichtsvideo zu typischen Architekturmustern" class="limited-width">
                <lsx-youtube video="Q7580888ce4" aspect-ratio="16x9" style="width: 50em; max-width: 100%;"></lsx-youtube>
                <a href="https://youtu.be/Q7580888ce4" target="_blank">Link zum Video</a>
            
                <lsx-info-box type="warning" class="mt-3">
                    Die Einleitung des Videos ist nicht mehr ganz aktuell, da wir in der Vorlesung inzwischen
                    erst die Cloud-Architektur und dann die Programmierung besprechen. Auch programmieren wir
                    inzwischen in JavaScript und nicht mehr mit dem Spring Framework in Java. Von den gelegentlichen
                    Bezügen zu Java und Spring sind die Konzepte des Videos aber auch hier allgemeingültig.
                </lsx-info-box>
                <p>
                    <span class="red fw-bold">And now go!</span> 🏁 😅
                </p>
            </section>

            <!--
                https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2
                https://aaronparecki.com/oauth-2-simplified/
                https://www.keycloak.org/guides#operator
                https://apisix.apache.org/docs/apisix/tutorials/observe-your-api/
                https://www.jaegertracing.io/docs/1.42/
                https://www.techtarget.com/searchitoperations/tip/The-3-pillars-of-observability-Logs-metrics-and-traces
                https://community.openhab.org/t/using-loki-promtail-grafana-for-openhab-system-and-log-monitoring/130853
                https://grafana.com/docs/tempo/latest/getting-started/tempo-in-grafana/

                - BILD: Weitere Services / Planes
                - Metriken, Logging, Tracing
                - Fowler: Circuit Breaker

                Fehlertoleranz
                Sicherheit
            -->

            <section data-title="Überwachung von Microservices">
                <div class="markdown dhbw-limited-width m-auto mb-5">
                    Typische Services in der **Kontrollebene** sind jene zur Überwachung des laufenden
                    Betriebs einer Cloud-Anwendung. Diese unterteilen sich typischerweise in:

                    * **Metriken:**: Kennzahlen wie Speicherverbrauch, Anzahl Requests je Sekunde, CPU-Auslastung, ...
                    * **Logging:** Protokollausgaben der einzelnen Services, um Fehler nachvollziehen zu können
                    * **Tracing:** Nachverfolgung von Aufrufketten, um komplexe Fehlersituationen analysieren zu können
                </div>
                <div class="d-flex align-items-stretch" style="gap: 1em;">
                    <img src="metriken.png" class="d-block w-100 img-thumbnail" />
                    <img src="logging.png" class="d-block w-100 img-thumbnail" />
                    <img src="tracing.png" class="d-block w-100 img-thumbnail" />
                </div>
            </section>

            <section data-title="Zwei-Faktor-Authentifizierung ja oder nein?" class="dhbw-limited-width">
                <img src="ct-schlagseite-2fa.jpg" class="d-block w-100" alt="Jeden Tag verschwindet einer …">
            
                <small>
                    <small>
                        Bildnachweis:
                        <a href="https://www.heise.de/select/ct/2022/11/2200714175714756235" target="_blank">c't 11/2022, S. 13 (Schlagseite)</a>
                    </small>
                </small>
            </section>

            <!--
            <section data-title="Fallbeispiel: Webflicks">
                <div class="mb-3">
                    <lsx-github-edit
                        url="https://github.com/DennisSchulmeister/dhbwka-wwi-vertsys-2022-quellcodes/tree/main/Beispielanwendung%20Webflicks"></lsx-github-edit>
                </div>
            
                <div class="d-flex flex-column flex-md-row gap-3">
                    <img src="beispiel-webflicks-1.png" class="img-thumbnail d-block w-100">
                    <img src="beispiel-webflicks-2.png" class="img-thumbnail d-block w-100">
                    <img src="beispiel-webflicks-3.png" class="img-thumbnail d-block w-100">
                </div>
            </section>
            -->

            <!--
                Folie mit Bild zum Umschalten: Bewertung verschiedener Architekturmuster (Kopplung, Synchron/Asynchron, Workflow, ...)
            -->
            <!--
            <section data-title="Vor- und Nachteile verschiedene Architekturansätze">
                <div class="dropdown mb-3">
                    <button
                        id             = "architekturbeispiele-dropdown"
                        class          = "btn btn-outline-secondary dropdown-toggle"
                        style          = "font-size: 0.9rem;"
                        type           = "button"
                        data-bs-toggle = "dropdown"
                        aria-haspopup  = "true"
                        aria-expanded  = "false"
                    >
                        TODO: Architekturbeispiel 1
                    </button>
                    <ul class="dropdown-menu">
                        <li>
                            <button
                                class          = "dropdown-item"
                                type           = "button"
                                data-dropdown  = "#architekturbeispiele-dropdown"
                                data-container = "#architekturbeispiele-bilder"
                                data-show      = "#architekturbeispiele-bilder-1"
                                onclick        = "change_example(event)"
                            >
                                TODO: Architekturbeispiel 1
                            </button>
                        </li>
                        <li>
                            <button
                                class          = "dropdown-item"
                                type           = "button"
                                data-dropdown  = "#architekturbeispiele-dropdown"
                                data-container = "#architekturbeispiele-bilder"
                                data-show      = "#architekturbeispiele-bilder-2"
                                onclick        = "change_example(event)"
                            >
                                TODO: Architekturbeispiel 2
                            </button>
                        </li>
                    </ul>
                </div>

                <div id="architekturbeispiele-bilder">
                    <lsx-grid-fluid id="architekturbeispiele-bilder-1" class="p-0 mt-3" >
                        <lsx-row>
                            <lsx-col size="md-8" class="mb-3">
                                <img src="microservices-gateway.png" class="d-block w-100" />
                            </lsx-col>
                            <lsx-col size="md" class="markdown">
                                xxx - Gateway
    
                                ### Vorteile dieser Architektur {.mt-4}
    
                                * xxx
                                * xxx
                                * xxx
    
                                ### Nachteile dieser Architektur {.mt-4}
    
                                * xxx
                                * xxx
                                * xxx
                            </lsx-col>
                        </lsx-row>
                    </lsx-grid-fluid>
    
                    <lsx-grid-fluid id="architekturbeispiele-bilder-2" class="p-0 mt-3 hidden">
                        <lsx-row>
                            <lsx-col size="md-8" class="mb-3">
                                <img src="microservices-compositeui.png" class="d-block w-100" />
                            </lsx-col>
                            <lsx-col size="md" class="markdown">
                                xxx - Composite UI
                    
                                ### Vorteile dieser Architektur {.mt-4}
                    
                                * xxx
                                * xxx
                                * xxx
                    
                                ### Nachteile dieser Architektur {.mt-4}
                    
                                * xxx
                                * xxx
                                * xxx
                            </lsx-col>
                        </lsx-row>
                    </lsx-grid-fluid>
                </div>
            </section>
            -->
        </main>

        <!-- Navigation -->
        <footer>
            <nav></nav>
        </footer>
    </body>
</html>