<!DOCTYPE html>
<html lang="de">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <title>Cloud-Architekturmuster | Verteilte Systeme</title>

        <script src="../_bundle.js"></script>
        <link rel="stylesheet" href="../_bundle.css" />
        <link rel="shortcut icon" href="../favicon.png" />

        <script>
            function change_example(event) {
                let label             = event.target.textContent       || "";
                let dropdownSelector  = event.target.dataset.dropdown  || "";
                let containerSelector = event.target.dataset.container || "";
                let showSelector      = event.target.dataset.show      || "";

                if (dropdownSelector) {
                    document.querySelectorAll(dropdownSelector).forEach(element => element.textContent = label);
                }
                if (containerSelector) {
                    document.querySelectorAll(`${containerSelector} > *`).forEach(element => element.classList.add("hidden"));
                }

                if (showSelector) {
                    document.querySelectorAll(showSelector).forEach(element => element.classList.remove("hidden"));
                }
            }
        </script>
    </head>

    <body class="hidden">
        <!-- Seitenkopf und Inhaltsverzeichnis -->
        <header>
            <div id="title">
                <h1>Cloud-Architekturmuster</h1>
                <h2 id="page-title"></h2>
            </div>

            <section id="toc" data-title="Inhaltsverzeichnis"></section>
        </header>

        <!-- Folien -->
        <main>
            <!-- ========== -->
            <!-- Einleitung -->
            <!-- ========== -->
            <section data-title="Einleitung" data-chapter></section>
            
            <section data-title="Lernziele" data-background-image="../trennfolie.jpg">
                <div class="card flex-fill mb-3">
                    <div class="card-header fw-bold dhbw-lightblue">
                        Skalierung in der Cloud
                    </div>
                    <div class="card-body p-3 markdown">
                        * Das Cloud-Betriebsmodell von klassischem Hosting unterscheiden können
                        * Verschiedene Arten von **As-a-Service**-Angeboten einordnen können
                        * Die Vor- und Nachteile einer **Microservice-Architektur** erklären können
                        * Die typischen Probleme monolithischer Anwendungen einordnen können
                        * **Elastizität und Skalierung** in der Cloud beschreiben können
                        * Die Begriffe **12-Faktor-App** und **Cloud Native App** erklären können
                        * Typische Architekturmuster wie **API-Gateway** oder **Cloud Messaging** kennen
                    </div>
                </div>
                <div class="card flex-fill mb-3">
                    <div class="card-header fw-bold dhbw-lightblue">
                        Umgang mit Fehlersituationen
                    </div>
                    <div class="card-body p-3 markdown">
                        * Die Wichtigkeit von **Observability** für verteilte Anwendungen verstehen
                        * Nutzen und Zusammenspiel von **Logs, Traces und Metriken** beschreiben können
                        * **Technische Strategien zur Fehlerbehandlung** wie das Circuit Breaker Pattern kennen
                        * **Fachliche Strategien zur Fehlerbehandlung** wie Compensating Action kennen
                        * Die Vor- und Nachteile dezentral implementierter Geschäftslogik kennen
                    </div>
                </div>
                <div class="card flex-fill">
                    <div class="card-header fw-bold dhbw-lightblue">
                        Cloud-Anwendungen absichern
                    </div>
                    <div class="card-body p-3 markdown">
                        * Die Begriffe **Data at Rest** und **Data in Transit** kennen
                        * Die Begriffe **Authentizität**, **Vertraulichkeit** und **Integrität** abgrenzen können
                        * Sicherungsmaßnahmen auf Netzwerkebene wie SSL oder **Network Level Isolation** verstehen
                        * Anwendungsfälle und die grundsätzliche Implementierung von **OAuth** kennen
                    </div>
                </div>
            </section>

            <!-- ============================= -->
            <!-- Definition des Cloud-Begriffs -->
            <!-- ============================= -->
            <section data-title="Definition des Cloud-Begriffs" data-chapter></section>
            <section data-title="Definition des Cloud-Begriffs" data-background-image="../trennfolie.jpg"></section>

            <section data-title="Grundlagen der Cloud-Architektur" class="markdown limited-width">
                <lsx-youtube video="_epyprLse_4" aspect-ratio="16x9" style="width: 50em; max-width: 100%;"></lsx-youtube>
            
                [Link zum Video](https://youtu.be/_epyprLse_4)

                <lsx-info-box type="warning">
                    Das Video bezieht sich an manchen Stellen noch auf die Entwicklung mit Java und
                    dem Spring-Framework. Auch wenn wir inzwischen Node.js/JavaScript in der Vorlesung
                    verwenden, sind die Grundprinzipien jedoch dieselben.
                </lsx-info-box>
            </section>

            <section data-title="Die Cloud aus Konsumentensicht" class="dhbw-limited-width2">
                <img src="cloud-storage.png" class="d-block w-100 mb-5">

                <div class="d-flex flex-column flex-md-row gap-2">
                    <img src="cat1.jpg" class="d-block w-100 img-thumbnail">
                    <img src="cat2.jpg" class="d-block w-100 img-thumbnail">
                    <img src="cat3.jpg" class="d-block w-100 img-thumbnail">
                    <img src="cat4.jpg" class="d-block w-100 img-thumbnail">
                </div>

                <small>
                    <small>
                        Zitat gefunden auf:
                        <a href="https://docs.kraudcloud.com/technology/storage/" target="_blank">kraudcloud.com</a>, <br>
                        
                        Bildnachweise:
                        <a href="https://pixabay.com/photos/cat-pet-licking-animal-tabby-cat-323262/" target="_blank">Pixabay: TeamK</a>,
                        <a href="https://pixabay.com/photos/cat-kitten-pets-animals-housecat-2934720/" target="_blank">Pixabay: Kirgiz03</a>,
                        <a href="https://pixabay.com/photos/cat-siamese-cat-fur-kitten-2068462/" target="_blank">Pixabay: webandi</a>,
                        <a href="https://pixabay.com/photos/cat-tired-yawn-stretch-814952/" target="_blank">Pixabay: jonathansautter</a>
                    </small>
                </small>
            </section>

            <section data-title="Abgrenzung von typischen Onlinediensten" class="dhbw-limited-width2">
                <div class="markdown mt-3 mb-3">
                    Anwendungen zum Synchronisieren von Dateien wie Dropbox, OneDrive oder Owncloud
                    werden umgangssprachlich oft als Cloud bezeichnet. Man sagt, dass die Dateien
                    _mit der Cloud synchronisiert_ werden. Dies ist jedoch problematisch, da „Cloud”
                    hier lediglich sinnbildlich für einen irgendwie gearteten Onlinedienst steht.
                    Hinzu kommt, dass zumindest Owncloud gar keine Cloud-Anwendung ist, sondern eine
                    in PHP implementierte, traditionelle Webanwendung. Nach dieser Definition müsste
                    demnach jede Webanwendung auch eine Cloud-Anwendung sein.
                </div>

                <lsx-grid-fluid class="p-0">
                    <lsx-row>
                        <lsx-col size="md">
                            <img src="dropbox-screenshot.png" class="d-block img-thumbnail" style="height: 100%;"/>
                        </lsx-col>
                        <lsx-col size="md">
                            <img src="owncloud-screenshot.png" class="d-block img-thumbnail" style="height: 100%;"/>
                        </lsx-col>
                    </lsx-row><lsx-row>
                        <lsx-col size="md">
                            <img src="owncloud-quellcode.png" class="d-block img-thumbnail" style="height: 100%;"/>
                        </lsx-col>
                        <lsx-col size="md">
                            <img src="owncloud-installation.png" class="d-block img-thumbnail" style="height: 100%;"/>
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </section>

            <section data-title="Abgrenzung von klassischem Hosting" class="dhbw-limited-width2">
                <div class="markdown mt-3 mb-3">
                    Schon früher war es insbesondere für kleinere Unternehmen üblich, die Hardware zur
                    Bereitstellung eines Onlinedienstes nicht selbst zu betreiben. Dieses Modell wird
                    Hosting genannt, da der Anbieter zwar die Hardwareplattform (den Host) zur Verfügung
                    stellt, Installation und Betrieb der Anwendung aber immer noch selbst vorgenommen
                    werden müssen.
                </div>

                <div class="d-flex gap-3 flex-column flex-md-row">
                    <div class="card flex-grow-1 w-100">
                        <img src="hosting-dedicated.jpg" class="card-img-top">
                        <div class="card-header border-top fw-bold">
                            Dedicated Root Server                        
                        </div>
                        <div class="card-body markdown small">
                            Hier vermietet der Anbieter einen dedizierten Computer an den Kunden.
                            Installation und Einrichtung müssen, sofern es kein „managed” Angebot
                            mit zusätzlicher Dienstleistung ist, aus der Ferne selbst erledigt werden.
                            Im Gegenzug können jedes beliebige Betriebsystem und jede Software
                            aufgespielt werden.
                        </div>
                    </div>

                    <div class="card flex-grow-1 w-100">
                        <img src="hosting-vserver.png" class="card-img-top">
                        <div class="card-header border-top fw-bold">
                            Virtual Private Server
                        </div>
                        <div class="card-body markdown small">
                            Hier steht eine virtuelle Maschine zur Verfügung, die sich weitgehend wie
                            dedizierte Hardware nutzen lässt. Die Ressourcen können jedoch geringer
                            ausfallen, da die Hardware von vielen Kunden geteilt wird. Die Installation
                            eines eigenen Betriebssystems kann ebenfalls mit Einschränkungen verbunden sein.
                        </div>
                    </div>

                    <div class="card flex-grow-1 w-100">
                        <img src="hosting-web.png" class="card-img-top">
                        <div class="card-header border-top fw-bold">
                            Web Hosting
                        </div>
                        <div class="card-body markdown small">
                            Hier wird lediglich der Webserver virtualisiert und etwas Speicherplatz in
                            einer vorkonfigurierten Serverfarm angeboten. Die Einstellungsmöglichkeiten
                            sind sehr begrenzt und oft auf traditionelle Webanwendungen mit PHP als
                            Programmiersprache und MariaDB als Datenbank zugeschnitten.
                        </div>
                    </div>
                </div>

                <small>
                    <small>
                        ¹ Bildnachweis:
                        <a href="https://pixabay.com/photos/technology-servers-server-1587673/" target="_blank">Pixabay: heladodementa</a>
                    </small>
                </small>
            </section>

            <section data-title="Virtualisierung im Hosting" class="dhbw-limited-width2">
                <div class="dhbw-limited-width m-auto mb-5">
                    <div class="markdown mb-3 mt-3">
                        Um ökonomische Skaleneffekte auszunutzen, beruhen die meisten Hostingangebote auf
                        der Virtualisierung bestimmter Ressourcen, wobei der Begriff auf zwei Arten definiert
                        werden kann.
                    </div>
                    <lsx-accordion>
                        <lsx-accordion-page title="Virtualität im allgemein Wortsinn">
                            <blockquote class="blockquote">
                                <p class="small">
                                    Virtualität ist die Eigenschaft einer Sache, nicht in der Form zu existieren,
                                    in der sie zu existieren scheint, aber in ihrem Wesen oder ihrer Wirkung einer
                                    in dieser Form existierenden Sache zu gleichen. Virtualität bezeichnet also eine
                                    gedachte Entität, die in ihrer Funktionalität oder Wirkung vorhanden ist.
                                </p>
                                <figcaption class="blockquote-footer small">
                                    <cite>Wikipedia zum Begriff „Virtualität”</cite>
                                </figcaption>
                            </blockquote>
                        </lsx-accordion-page>
    
                        <lsx-accordion-page title="Virtualisierung in der Informatik">
                            <blockquote class="blockquote">
                                <p class="small">
                                    Virtualisierung bezeichnet in der Informatik die Nachbildung eines Hard- oder
                                    Software-Objekts durch ein ähnliches Objekt vom selben Typ mit Hilfe einer
                                    Abstraktionsschicht. Dadurch lassen sich virtuelle (d.&nbsp;h. nicht-physische)
                                    Geräte oder Dienste wie emulierte Hardware, Betriebssysteme, Datenspeicher oder
                                    Netzwerkressourcen erzeugen.
                                </p>
                                <figcaption class="blockquote-footer small">
                                    <cite>Wikipedia zum Begriff „Virtualisierung”</cite>
                                </figcaption>
                            </blockquote>
                        </lsx-accordion-page>
                    </lsx-accordion>
                </div>

                <div class="d-flex gap-3 flex-column flex-md-row">
                    <div class="flex-grow-1 w-100 markdown small">
                        <img src="virtualisierung-hardware.png" class="w-100 mb-3" alt="Hardware-Virtualisierung">
                        
                        Virtualisierte Hardware bietet die größte Flexibilität, da sie sich aus Kundensicht
                        wie dedizierte Hardware verhält. Der Kunde mietet zwar keinen physischen Computer,
                        kann aber dennoch beliebige Software aufspielen.
                    </div>
                    <div class="flex-grow-1 w-100 markdown small">
                        <img src="virtualisierung-betriebssystem.png" class="w-100 mb-3" alt="Betriebssystem-Virtualisierung">
                        
                        Preisgünstigere Angebote virtualisieren in der Regel nur das Betriebssystem, wodurch
                        mehr Kunden bedient werden können. Die Installation beschränkt sich daher auf kompatible
                        Systemumgebungen und Anwendungen.
                    </div>
                    <div class="flex-grow-1 w-100 markdown small">
                        <img src="virtualisierung-server.png" class="w-100 mb-3" alt="Server-Virtualisierung">
                        
                        Einfache Hostingangebote virtualisieren lediglich die Serveranwendung. Die Kunden bekommen
                        eine eigene Domain und etwas Speicherplatz mit sehr beschränkten Einstellungsmöglichkeiten.
                    </div>
                </div>

                <small>
                    <small>
                        Bildnachweise:
                        <a href="https://de.wikipedia.org/wiki/Datei:Apache_Feather_Logo.svg" target="_blank">Wikipedia: Apache_Feather_Logo.svg</a>,
                        <a href="https://de.m.wikipedia.org/wiki/Datei:Tux.svg" target="_blank">Wikipedia: Tux.svg</a>,
                        <a href="https://commons.wikimedia.org/wiki/File:Daemon-phk.svg" target="_blank">Wikipedia: Daemon-phk.svg</a>,
                        <a href="https://de.m.wikipedia.org/wiki/Datei:Windows_logo_-_2012.svg" target="_blank">Wikipedia: Windows logo - 2012.svg</a>,
                        <a href="https://icon-icons.com/de/symbol/tux-logo/214728" target="_blank">icon-icons.com: Tux Logo</a>
                    </small>
                </small>
            </section>

            <section data-title="Grundidee der Cloud" class="mb-3">
                <lsx-grid-fluid class="p-0">
                    <lsx-row>
                        <lsx-col size="md-9" class="mb-3">
                            <img src="cloud-betriebsmodell.png" class="d-block w-100" />
                        </lsx-col>
                        <lsx-col size="md" class="d-flex flex-column gap-3">
                            <div class="card">
                                <div class="card-header fw-bold">
                                    Automatisierung
                                </div>
                                <div class="card-body markdown small">
                                    Die Grundidee der Cloud ist, die Bereitstellung und den Betrieb verteilter
                                    Anwendungen so weit wie möglich zu automatisieren. Eine Cloudumgebung besteht
                                    daher aus einem großen Rechencluster, dessen Ressourcen auf viele Anwendungen
                                    aufgeteilt werden. Manuelle Installationsschritte sollen vermieden werden.
                                    {.mb-0}
                                </div>
                            </div>

                            <div class="card">
                                <div class="card-header fw-bold">
                                    Isolation
                                </div>
                                <div class="card-body markdown small">
                                    Die physischen und virtuellen Maschinen sowie Speicherressourcen einer Cloudumgebung
                                    werden vollständig abstrahiert, wodurch jede Anwendung einen eigenen, **virtuellen
                                    Computercluster** erhält. Häufig (aber nicht immer) wird dabei auch das Netzwerk
                                    virtualisiert, wodurch interne Services in einem **privaten Netzwerk** vor öffentlichen
                                    Zugriffen geschützt werden können.
                                    {.mb-0}
                                </div>
                            </div>

                            <div class="card">
                                <div class="card-header fw-bold">
                                    Skalierung und Elastizität
                                </div>
                                <div class="card-body markdown small">
                                    **Skalierung** beschreibt die Anpassung der zur Verfügung gestellten Ressourcen
                                    entsprechend dem Leistungsbedarf einer Anwendung. Beim klassischen Hosting und
                                    bei sehr einfachen Cloud-Installationen ist dies nur durch manuelles Eingreifen
                                    möglich. Echte Cloud-Anwendungen sind jedoch **elastisch**, so dass der Cluster
                                    die Ressourcen automatisch skalieren kann.
                                    {.mb-0}
                                </div>
                            </div>

                            <div class="card">
                                <div class="card-header fw-bold">
                                    Variable Kosten
                                </div>
                                <div class="card-body markdown small">
                                    Aufgrund der dynamischen Ressourcenzuteilung bieten viele Cloud-Angebote eine
                                    **nutzungsabhängige Abrechnung**, die sich nach Anzahl der tatsächlich genutzten
                                    Minuten zur Ausführung von Programmcode, tatsächlich belegtem Speicherplatz
                                    oder Netzwerktraffic richtet. Im Vergleich zu klassischem Hosting fallen die
                                    durchschnittlichen Kosten daher oft geringer aus.
                                    {.mb-0}
                                </div>
                            </div>
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </section>

            <section data-title="Das As-a-Service-Geschäftsmodell" class="dhbw-limited-width2">
                <div class="markdown mt-3 mb-5">
                    Cloudangebote werden häufig mit dem Namenszusatz „as-a-Service” angeboten,
                    wie beispielsweise „Database-as-a-Service“ oder „Software-as-a-Service".
                    Damit ist gemeint, dass die jeweilige Software **nicht klassisch lizenziert,
                    sondern als Dienstleistung** vermarktet wird. Installation, Betrieb und Pflege
                    werden fallen in die Verantwortung des Anbieters, wodurch diese aus Kundensicht
                    komplett ausgelagert werden können.
                </div>

                <div class="d-flex gap-3 flex-column flex-md-row mb-4">
                    <div class="flex-grow-1 w-100 markdown small">
                        ### Infrastructure-as-a-Service {.mb-3}

                        <img src="modelle-iaas.png" class="w-100 mb-3">
                
                        Im einfachsten Fall stellt die Cloud virtuelle Maschinen zur manuellen Einrichtung
                        sowie dazugehörige Dienste wie Objektspeicher und Netzwerkrouting zur Verfügung.
                        Lediglich die Bereitstellung aus Sicht des Cloudanbieters wird dabei automatisiert.
                    </div>
                    <div class="flex-grow-1 w-100 markdown small">
                        ### Platform-as-a-Service {.mb-3}

                        <img src="modelle-paas.png" class="w-100 mb-3">
                
                        Auf die Entwicklung von Cloudanwendungen zugeschnittene Angebote bieten eine
                        vorkonfigurierte Laufzeitumgebung für selbstgeschriebenen Quellcode. Deployment
                        und Betrieb werden weitgehend automatisiert. Es besteht jedoch die Gefahr von
                        Vendor Lock-In aufgrund der Verwendung anbieterspezifischer Bibliotheken.
                    </div>
                    <div class="flex-grow-1 w-100 markdown small">
                        ### Software-as-a-Service {.mb-3}

                        <img src="modelle-saas.png" class="w-100 mb-3">
                
                        Am weitesten abstrahiert sind SaaS-Angebote zur Bereitstellung ganzer Anwendungspakete.
                        Als Kunde registriert man sich lediglich für eine Anwendung, die gegen eine monatliche
                        Gebühr zur Verfügung gestellt wird. Alle Kunden teilen sich meist den Quellcode, während
                        die Daten getrennt werden.
                    </div>
                </div>

                <div class="markdown">
                    Angebote wie **Function-as-a-Service** (auch **Serverless** genannt, da die Verwaltung von Serverinstanzen komplett
                    wegabstrahiert wird) oder **Database-as-a-Service** richten ebenfalls an Anwendungsentwickler und zählen deshalb zu
                    Platform-as-a-Service.
                    
                    Die großen Anbieter wie Amazon, Google oder Microsoft bieten grundsätzlich eine Mischung aus allen Modellen, während
                    sich kleinere Anbieter wie [Heroku](https://heroku.com/){target="_blank"}, [Render](https://render.com/){target="_blank"},
                    [Fly.io](https://fly.io/){target="_blank"} meist auf Plattformdienste beschränken.
                    [MongoDB Atlas](https://www.mongodb.com/de-de/atlas){target="_blank"}, [Auth0](https://auth0.com/){target="_blank"}
                    und viele mehr zielen hingegen auf ganz spezielle Anwendungsfälle ab.
                </div>
            </section>

            <section data-title="Container-Virtualisierung in der Cloud" class="w-100">
                <div class="dhbw-limited-width2 d-flex flex-column flex-lg-row align-items-center gap-3 m-auto mt-3 mb-4">
                    <img src="virtualisierung-container.png" class="d-block" style="width: 24em; max-width: 100%;">
                    <div class="markdown flex-grow-1">
                        Viele Cloudumgebungen nutzen Container-Virtualisierung, um beliebige Workloads ausführen zu können.
                        Die auszuführenden Anwendungen und Services werden hierfür in **Anwendungscontainer** verpackt, die ein
                        **sehr abgespecktes Dateisystem** mit den notwendigsten **Bibliotheken**, **Hilfsprogrammen** sowie
                        dem **Anwendungscode** beinhalten und somit das zugrunde liegende Linux-System **wegabstrahieren**.
                        Der Anwendung wird dadurch vorgetäuscht, sie sei die einzige innerhalb des Host-Betriebssystems
                        ausgeführte Anwendung, was **Isolation** genannt wird.

                        Hierbei wird zwischen Container-Abbild (Image) und Container-Instanz unterschieden:

                         * **Image:** Binärpaket, das innerhalb der Cloud deployed werden kann
                         * **Instanz:** Tatsächlich ausgeführter Container auf einem Rechnerknoten
                        
                        Die Erstellung der Images wird grundsätzlich automatisiert. Unterschiede bestehen lediglich in
                        den verwendeten Werkzeugen und den hierfür benötigten Konfigurationsdateien. Typische Quellcodes einer
                        bestimmten Programmiersprache können häufig ohne Konfiguration direkt deployed werden, wobei ein in der
                        Cloud laufendes **Buildpack** diese in Anwendungscontainer verpackt. Meist kann der Prozess durch
                        zusätzliche Konfigurationsdateien beeinflusst werden, wenn man die Container nicht alternativ selbst baut. {.mb-0}
                    </div>
                </div>
                
                <div class="dhbw-limited-width2 m-auto mb-5 markdown">
                    Das folgende Beispiel zeigt einen typischen **DevOps-Workflow**, bei dem die Anwendungscontainer durch eine
                    Continous-Integration/Continous-Deployment-Pipeline automatisiert gebaut, in einer Container-Registrierung
                    abgelegt und anschließend in der Cloud deployed werden.
                </div>
                <img src="devops.png" class="img-fluid w-100">
            </section>

            <!-- ================================== -->
            <!-- Verteilte Anwendungen in der Cloud -->
            <!-- ================================== -->
            <section data-title="Verteilte Anwendungen in der Cloud" data-chapter></section>
            <section data-title="Verteilte Anwendungen in der Cloud" data-background-image="../trennfolie.jpg"></section>

            <section data-title="Anwendungsarchitektur früher">
                <lsx-grid-fluid class="p-0">
                    <lsx-row>
                        <lsx-col size="md-8" class="mb-3">
                            <img src="monolith.png" class="d-block w-100" />
                        </lsx-col>
                        <lsx-col size="md" class="markdown">
                            Frühere Anwendungsarchitekturen, bei denen sämtliche Funktionen in einer großen Codebasis
                            untergebracht waren, werden heute als **Monolith** bezeichnet. Zwar kann der Quellcode
                            durchaus modular aufgebaut und somit leicht um neue Funktionen erweiterbar sein. Jedoch
                            kann die Anwendung nur als Ganzes deployed und in Betrieb genommen werden.

                            ### Vorteile eines Monolithen {.mt-4}

                            * Einfache Anwendungsarchitektur mit wenigen Komponenten
                            * Insbesondere für kleine Entwicklerteams leicht handlebar
                            * Eine Programmiersprache für alle Teile der Anwendung
                            * Direkter Datenaustausch zwischen den Anwendungskomponenten
                            * Anwendungskomponenten können sich gegenseitig direkt aufrufen

                            ### Nachteile eines Monolithen {.mt-4}

                            * Unpraktisch für sehr große Anwendungen mit vielen Funktionen
                            * Auswirkungen einer Quellcodeänderung sind oft schwer nachvollziehbar
                            * In großen Entwicklerteams kommt es oft zu gegenseitigen Störungen
                            * Kein getrenntes Deployment einzelner Anwendungsfunktionen möglich
                            * Vor jedem Deployment muss die komplette Anwendung getestet werden
                            * Fehlerkorrekturen brauchen daher oft lange, bis sie produktiv gehen
                            * Die Anwendung kann nur als Ganzes skaliert werden

                            Cloudanwendungen werden daher häufig mit einer *Microservice-Architektur* gestaltet.
                            Für kleine Entwicklerteams kann ein Monolith trotzdem die bessere Wahl sein. {.mt-4}
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </section>

            <section data-title="Probleme beim Deployment monolithischer Anwendungen" class="dhbw-limited-width2 p-3">
                <div class="d-flex flex-column flex-md-row gap-5">
                    <img src="wanted-monolith.jpg" class="d-block w-100" alt="Wanted! The Monolith …">
                    <img src="code-freeze.jpg" class="d-block w-100" alt="It's really, really, really, really code freeze">
                </div>

                <small>
                    <small>
                        Bildnachweise:
                        <a href="https://turnoff.us/geek/not-wanted/" target="_blank">{turnoff.us} not wanted</a>,
                        <a href="https://geek-and-poke.com/geekandpoke/2015/3/25/code-freeze" target="_blank">Geek & Poke: Code Freeze</a>
                    </small>
                </small>
            </section>

            <section data-title="Anwendungsarchitektur heute">
                <lsx-grid-fluid class="p-0 mt-3">
                    <lsx-row>
                        <lsx-col size="md-8" class="mb-3">
                            <div class="dropdown mb-3">
                                <button
                                    id             = "microservices-dropdown"
                                    class          = "btn btn-outline-secondary dropdown-toggle"
                                    style          = "font-size: 0.9rem;"
                                    type           = "button"
                                    data-bs-toggle = "dropdown"
                                    aria-haspopup  = "true"
                                    aria-expanded  = "false"
                                >
                                    Single Page App mit API-Gateway
                                </button>
                                <ul class="dropdown-menu">
                                    <li>
                                        <button
                                            class          = "dropdown-item"
                                            type           = "button"
                                            data-dropdown  = "#microservices-dropdown"
                                            data-container = "#microservices-bilder"
                                            data-show      = "#microservices-bilder-1"
                                            onclick        = "change_example(event)"
                                        >
                                            Single Page App mit API-Gateway
                                        </button>
                                    </li>
                                    <li>
                                        <button
                                            class          = "dropdown-item"
                                            type           = "button"
                                            data-dropdown  = "#microservices-dropdown"
                                            data-container = "#microservices-bilder"
                                            data-show      = "#microservices-bilder-2"
                                            onclick        = "change_example(event)"
                                        >
                                            Webanwendung mit Composite UI
                                        </button>
                                    </li>
                                </ul>
                            </div>

                            <div id="microservices-bilder">
                                <img id="microservices-bilder-1" src="microservices-gateway.png" class="d-block w-100" />
                                <img id="microservices-bilder-2" src="microservices-compositeui.png" class="d-block w-100 hidden" />
                            </div>
                        </lsx-col>
                        <lsx-col size="md" class="markdown">
                            Moderne Anwendungen werden heute oft als **Microservice-Architektur** ausgeführt, in welcher die
                            Teilfunktionen einer Anwendung in einzelne Serverdienste ausgelagert werden. Microservice-basierte
                            Anwendungen sind daher immer verteilte Anwendungen. Dabei bildet jeder Microservice eine getrennte
                            Einheit, die weitgehend unabhängig entwickelt, deployed und betrieben wird. Meistens besitzt jeder
                            Microservice deshalb eine eigene Datenbank, auf deren Inhalte nur über die öffentliche Schnittstelle
                            des Microservices entfernt zugegriffen werden kann. Martin Fowler definiert Microservices
                            [auf seiner Webseite](https://martinfowler.com/microservices/){target=_blank} daher wie folgt:

                            * Entfernte Serverdienste als Teilkomponenten einer Anwendung
                            * Dezentralisierte Verwaltung und dezentrales Datenmanagement
                            * Entsprechen oft organisatorischer Unternehmenseinheiten
                            * Deshalb meist langfristig durch eigenständige Teams betreut
                            * Über eine öffentliche Schnittstelle entfernt aufrufbar
                            * Fehlertoleranter Entwurf mit evolutionärem Design
                            * Hoher Automatisierungsgrad für Betrieb und Weiterentwicklung

                            Die öffentliche Benutzeroberfläche einer Microservice-basierten Anwendung wird häufig als **Webanwendung**
                            oder **Mobile App** implementiert, wobei Webanwendungen zunehmend Single Page Apps sind, deren generelle
                            Anwendungslogik zwar im Browser läuft. Ein **Gateway-Server** versteckt dann in der Regel die einzelnen
                            Backend-Services vor dem Frontend. Alternativ können die Microservices aber auch so genannte **Microfrontends**
                            bereitstellen, die jeweils einen Ausschnitt der darzustellenden Bildschirminhalte liefern und nach dem
                            **Composite UI Pattern** innerhalb eines Anwendungsrahmens eingeblendet werden.

                            ### Vorteile von Microservices {.mt-4}

                            * Die Services sind durch ihre Schnittstellen klar gekapselt.
                            * Jeder Service kann einzeln deployed und skaliert werden.
                            * Sprachen, Bibliotheken, … können passend zum Service ausgewählt werden.

                            ### Nachteile von Microservices {.mt-4}

                            * Verteilte Systeme mit vielen Komponenten sind schwer zu programmieren.
                            * Microservices müssen eventuellkonsistent und fehlertolerant programmiert werden.
                            * Deployment, Betrieb und Überwachung bringen zusätzliche Komplexität.

                            Laut Martin Fowler lohnt sich eine Microservice-Architektur daher nur, wenn eine Anwendung hinreichend
                            groß ist und von mehreren Entwicklerteams betreut werden kann. Vgl.
                            [Martin Fowler: Microservice Guide](https://martinfowler.com/microservices/){target=_blank}
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </section>

            <section data-title="Herausforderungen bei der Nutzung von Microservices" class="dhbw-limited-width2 p-3">
                <div class="d-flex flex-column flex-md-row gap-3">
                    <img src="valentines-day.png" class="d-block w-100" alt="Happy Valentines Day">
                    <img src="microservices-and-monolithic.png" class="d-block w-100" alt="Are you ready for microservices?">
                </div>
            
                <small>
                    <small>
                        Bildnachweise:
                        <a href="https://turnoff.us/geek/valentines-day/" target="_blank">{turnoff.us} valentine's day at the kernel</a>,
                        <a href="https://turnoff.us/geek/are-you-ready-for-microservices/" target="_blank">{turnoff.us} are you ready for microservices?</a>
                    </small>
                </small>
            </section>

            <section data-title="Skalierung von Microservices" class="dhbw-limited-width2">
                <lsx-carousel class="carousel-fade">
                    <lsx-carousel-page>
                        <img src="skalierung-1.png" class="d-block w-100 mb-5">
                        <p>
                            Microservice-Architekturen lassen sich grundsätzlich einfacher skalieren als monolithische Anwendungen,
                            da jeder Service getrennt deployed wird. Für jeden Service kann daher eine optimale Ressourcenzuteilung
                            entsprechend dem tatsächlichen Bedarf vorgenommen werden.
                        </p>
                    </lsx-carousel-page>
                    <lsx-carousel-page>
                        <img src="skalierung-2.png" class="d-block w-100 mb-5">
                        <p>
                            Bei leicht ansteigender Last könnte die Cloudumgebung beispielsweise den laufenden Instanzen mehr
                            Leistung zur Verfügung stellen.
                        </p>
                    </lsx-carousel-page>
                    <lsx-carousel-page>
                        <img src="skalierung-3.png" class="d-block w-100 mb-5">
                        <p>
                            In der Regel werden so genannte Skalierungstrigger, wie die Anzahl HTTP-Anfragen je Sekunde, jedoch
                            genutzt, um weitere Serviceinstanzen zu starten. Die eingehenden Anfragen werden dann durch einen Load
                            Balancer gleichmäßig auf die Instanzen verteilt.
                        </p>
                    </lsx-carousel-page>
                    <lsx-carousel-page>
                        <img src="skalierung-4.png" class="d-block w-100 mb-5">
                        <p>
                            Damit diese Art der Skalierung funktioniert, dürfen die Services allerdings keine temporären Sitzungdaten
                            im Hauptspeicher ablegen. Denn es kann in der Regel nicht garantiert werden, dass zusammengehörige Anfragen
                            stets dieselbe Instanz erreichen. Außerdem können die Instanzen jederzeit neugestartet werden, wodurch die
                            im Hauptspeicher liegenden Daten ebenfalls verloren gingen.
                        </p>
                    </lsx-carousel-page>
                    <lsx-carousel-page>
                        <img src="skalierung-5.png" class="d-block w-100 mb-5">
                        <p>
                            Cloud-Anwendungen, welche serverseitige Sitzungsdaten verwalten, persistieren diese daher meist in einer
                            Datenbank. Oft wird hierfür dieselbe Datenbank genutzt, in der auch die originären Nutzdaten des jeweiligen
                            Microservices liegen. Genauso oft kommen allerdings auch spezialisierte Datenbanken oder Objektspeicher
                            wie Redis zum Einsatz.
                        </p>
                    </lsx-carousel-page>
                    <lsx-carousel-page>
                        <img src="skalierung-6.png" class="d-block w-100 mb-5">
                        <p>
                            Idealerweise benötigt eine Anwendung überhaupt keine serverseitigen Sitzungsdaten, sondern verwaltet diese
                            rein clientseitig. Dadurch werden der Server entlastet und Zeitverzögerungen aufgrund einer langsamen
                            Internetverbindung vermieden. Gemäß
                            <a href="https://martinfowler.com/articles/distributed-objects-microservices.html" target="_blank">Martin Fowler's „First Law of Distributed Objects”</a>
                            funktioniert dies am besten, wenn die Kommunikation mit dem Backend auf wenige Anfragen mit gebündelten
                            Inhalten reduziert wird.
                        </p>
                    </lsx-carousel-page>

                    <lsx-carousel-page>
                        <img class="active d-block w-25 m-auto" src="../finish.svg" />
                        <p>
                            Wird eine Anwendung nach den vorgenannten Prinzipien serverseitig möglichst zustandslos implementiert,
                            kann sie jederzeit problemlos hoch- oder runterskaliert werden.
                        </p>
                    </lsx-carousel-page>
                </lsx-carousel>
            </section>

            <section data-title="12-Faktor-Apps / Cloud Native Apps">
                <lsx-grid-fluid>
                    <lsx-row>
                        <lsx-col size="lg">
                            <img src="12factor.net.png" class="d-block w-100 dhbw-border">
                        </lsx-col>
                        <lsx-col size="lg">
                            <div class="markdown">
                                Eine elastische Skalierung setzt voraus, dass jederzeit weitere Instanzen eines Services gestartet
                                oder nicht mehr benötigte Instanzen gestoppt werden können. Um dies zu vereinfachen, haben die Macher
                                der Heroku-Cloud auf der Webseite [12factor.net](https://12factor.net){target=_blank} das 12-Faktor-Manifest
                                mit zwölf Regeln für **Cloud Native Apps** (auch **12-Faktor-Apps** genannt) veröffentlicht. Diese lassen
                                sich wie folgt zusammenfassen:
                            </div>

                            <lsx-tab-pages>
                                <lsx-tab-page title="Entwicklung">
                                    <div class="markdown">
                                        * Zentral verwalteter Quellcode
                                        * Abhängigkeiten explizit deklarieren
                                        * Getrennte Build-, Release- und Run-Phasen
                                        * Vergleichbare Entwicklungs- und Produktivumgebungen
            
                                        Microservices werden mit modernen Werkzeugen und modernen Programmierpraktiken entwickelt. Ihr Quellcode
                                        wird deshalb mit Werkzeugen wie Git versioniert, so dass jede Änderung daran nachvollziehbar ist. Werkzeuge
                                        wie `npm`, `pip` oder `maven` verwalten darüber hinaus die Abhängigkeiten zu externen Bibliotheken und sorgen
                                        für automatisierte Build- und Releaseprozesse.
                                        
                                        Zusätzlich finden Entwicklung und Test und vergleichbaren Bedingungen wie der spätere Produktiveinsatz statt,
                                        wofür die Produktivumgebung auf den Entwicklungs- und Testmaschinen so gut wie möglich nachgebildet wird.
                                    </div>
                                </lsx-tab-page>

                                <lsx-tab-page title="Konfiguration">
                                    <div class="markdown">
                                        * Nutzung fremder Dienste über das Netzwerk
                                        * Unterstützende Dienste sind Ressourcen
                                        * Konfiguration durch Umgebungsvariablen
                                        * Adminprozesse sind einmalige Vorgänge

                                        Microservices kommunizieren grundsätzlich über das Netzwerk bzw. das Internet mit anderen Microservices.
                                        Andere Schnittstellen sind nicht vorgesehen, um die Microservices auf getrennten virtuellen Maschinen und
                                        oft sogar getrennten physischen Maschinen betreiben zu können. Über die Konfiguration der Services, welche
                                        innerhalb der Cloudumgebung vorgenommen wird, werden jedem Microservice die Netzadressen der von ihm benötigten
                                        anderen Services mitgeteilt. Diese stehen dann zur Laufzeit als Umgebungsvariablen des Betriebssystems zur
                                        Verfügung, da es sich hierbei um eine universale, einfache Möglichkeit handelt.

                                        Falls administrative Aktionen wie die Reorganisation einer Datenbank oder das Löschen veralteter Daten
                                        notwendig sind, erfolgen diese durch einmalig aufgerufene, vom eigentlichen Microservice getrennt laufende
                                        Werkzeugprogramme.
                                    </div>
                                </lsx-tab-page>

                                <lsx-tab-page title="Ausführung">
                                    <div class="markdown">
                                        * Ausführung als einzelner Betriebssystemprozess
                                        * Parallelität durch weitere Betriebssystemprozesse
                                        * Robuster und schneller Start bzw. Stopp der Prozesse
                                        * Protokollierung durch zeitbezogene Ereignisse

                                        Microservices sind immer in sich geschlossen und bringen sämtliche Laufzeitumgebungen, Bibliotheken und
                                        Hilfsprogramme mit, um ausgeführt werden zu können. Sie können dadurch als einzelner Betriebssystemprozess
                                        leicht gestartet und gestoppt werden, beispielsweise indem sie in ein Container-Image verpackt werden.
                                        Start und Stopp müssen besonders schnell gehen, damit die Skalierung jederzeit elastisch angpasst werden
                                        kann.

                                        Für die Fehlersuche schreiben Microservices umfangreiche Protokollmeldungen in die Konsole (ihne Standardausgabe).
                                        Jede Meldung wird dabei mit einem eindeutigen Zeitstempel am Anfang versehen, so dass die Protokollmeldungen
                                        von der Cloud wie ein kontinuierlicher Datenstrom von zeitpunktbezogenen Ereignissen behandelt und archiviert
                                        werden können.
                                    </div>
                                </lsx-tab-page>
                            </lsx-tab-pages>
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </section>

            <section data-title="Fallbeispiel: Adressbuch">
                <div class="mb-3">
                    <lsx-github-edit url="https://github.com/DennisSchulmeister/dhbwka-wwi-vertsys-2022-quellcodes/tree/main/Beispielanwendung%20Adressbuch"></lsx-github-edit>
                </div>

                <div class="d-flex flex-column flex-md-row gap-3">
                    <img src="beispiel-adressbuch-1.png" class="img-thumbnail d-block w-100">
                    <img src="beispiel-adressbuch-2.png" class="img-thumbnail d-block w-100">
                    <img src="beispiel-adressbuch-3.png" class="img-thumbnail d-block w-100">
                </div>
            </section>

            <!-- =========================== -->
            <!-- Architekturmuster im Detail -->
            <!-- =========================== -->
            <!--
            <section data-title="Architekturmuster im Detail" data-chapter></section>
            <section data-title="Architekturmuster im Detail" data-background-image="../trennfolie.jpg"></section>
            -->

            <!--
                https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2
                https://aaronparecki.com/oauth-2-simplified/
                https://www.keycloak.org/guides#operator
                https://apisix.apache.org/docs/apisix/tutorials/observe-your-api/
                https://www.jaegertracing.io/docs/1.42/
                https://www.techtarget.com/searchitoperations/tip/The-3-pillars-of-observability-Logs-metrics-and-traces
                https://community.openhab.org/t/using-loki-promtail-grafana-for-openhab-system-and-log-monitoring/130853
                https://grafana.com/docs/tempo/latest/getting-started/tempo-in-grafana/

                Fehlertoleranz
                Sicherheit
                Fallbeispiel Webflix (Folie analog Fallbeispiel Adressbuch nur Verweis auf den Code)
                Folie mit Bild zum Umschalten: Bewertung verschiedener Architekturmuster (Kopplung, Synchron/Asynchron, Workflow, ...)
            -->
        </main>

        <!-- Navigation -->
        <footer>
            <nav></nav>
        </footer>
    </body>
</html>